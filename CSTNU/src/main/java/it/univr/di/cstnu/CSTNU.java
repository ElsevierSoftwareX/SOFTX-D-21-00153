package it.univr.di.cstnu;

import it.univr.di.cstnu.WellDefinitionException.Type;

import java.util.AbstractMap.SimpleEntry;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeSet;
import java.util.logging.Logger;

/**
 * Simple class to represent and check Conditional Simple Temporal Network with Uncertainty (CSTNU).
 * It does not manage overflow cases when summing edge values.
 * 
 * @author posenato
 */
public class CSTNU {

	/**
	 * logger
	 */
	static Logger LOG = Logger.getLogger(CSTNU.class.getName());

	/**
	 * The name for the reference node.
	 */
	private static final String ZeroNodeName = "Z";

	/**
	 * Counters about the # of application of different rules.
	 */
	@SuppressWarnings("javadoc")
	static int R0calls, R1calls, R2calls, R3calls, R4calls, R5calls, R6calls, ObsCaseRule, NoCaseLabelcalls;

	/**
	 * @param n
	 * @return true if n is the Z node of the graph.
	 */
	static private boolean isZ(Node n) {
		if (n == null) return false;
		return ZeroNodeName.equals(n.getName());
	}

	/**
	 * Checks whether the new label to add or to use to replace another one subsumes the conjunction of labels of endpoint of the constraint.
	 * 
	 * @param source starting node of the constraint
	 * @param dest ending node of the constraint
	 * @param newLabel new label to add or to use
	 * @param edgeName name of constraint
	 * @param ruleName name of rule applied to determine the new label.
	 * @return false if the check fails, true otherwise
	 */
	static boolean checkNodeLabelsSubsumption(Node source, Node dest, Label newLabel, String edgeName, String ruleName) {

		if (source == null || dest == null || newLabel == null || edgeName == null) {
			CSTNU.LOG.warning("One parameter is null. source: " + source + ", dest: " + dest + ", new label to add: " + newLabel + ", edgeName: " + edgeName
					+ ". Please, check parameter.");
			return false;
		}
		final Label labelConjunction = source.getLabel().conjunction(dest.getLabel());
		if (!newLabel.subsumes(labelConjunction)) {
			CSTNU.LOG.warning("Subsumption check for a label generated by rule " + ruleName + " on edge " + edgeName
					+ ".\nThe new label, '" + newLabel + "', does not subsume the conjunction of node labels '" + labelConjunction
					+ "'.\nIt is reject!");
			return false;
		}
		return true;
	}

	/**
	 * Checks whether the constraint represented by edge e satisfies the well definition 1 property:<br>
	 * any labeled valued of the edge is satisfiable and subsumes both labels of two endpoints.
	 * 
	 * @param e edge representing a labeled constraint.
	 * @param tail the source node of the edge.
	 * @param head the destination node of the edge.
	 * @return false if the check fails, true otherwise
	 * @throws WellDefinitionException
	 */
	static boolean checkWellDefinition1Property(Node tail, Node head, Edge e) throws WellDefinitionException {
		if (e == null || tail == null || head == null) {
			CSTNU.LOG.warning("One parameter is null at least. Please, check parameter.");
			return false;
		}

		final Label labelConjunction = tail.getLabel().conjunction(head.getLabel());
		if (labelConjunction == null) {
			CSTNU.LOG.warning("Two endpoints don not allow any constraint because the have inconsisten labels.");
			throw new WellDefinitionException("Two endpoints don not allow any constraint because the have inconsisten labels.",
					WellDefinitionException.Type.LabelInconsistent);
		}
		// check the ordinary labeled values
		for (final Entry<Label, Integer> entry : e.getLabeledValueMap().labeledValueSet()) {
			if (!entry.getKey().subsumes(labelConjunction)) {
				CSTNU.LOG.warning("Labeled value " + entry + " of edge " + e.getName() + " does not subsume the endpoint labels.");
				throw new WellDefinitionException("Labeled value " + entry + " of edge " + e.getName() + " does not subsume the endpoint labels.",
						WellDefinitionException.Type.LabelNotSubsumes);
			}
		}
		// check the upper case labeled values
		for (final Entry<Entry<Label, String>, Integer> entry : e.getUpperLabelSet()) {
			if (!entry.getKey().getKey().subsumes(labelConjunction)) {
				CSTNU.LOG.warning("Upper case Labeled value " + entry + " of edge " + e.getName() + " does not subsume the endpoint labels.");
				throw new WellDefinitionException("Upper case Labeled value " + entry + " of edge " + e.getName() + " does not subsume the endpoint labels.",
						WellDefinitionException.Type.LabelNotSubsumes);
			}
		}
		// check the lower case labeled values
		for (final Entry<Entry<Label, String>, Integer> entry : e.getLowerLabelSet()) {
			if (!entry.getKey().getKey().subsumes(labelConjunction)) {
				CSTNU.LOG.warning("Lower case Labeled value " + entry + " of edge " + e.getName() + " does not subsume the endpoint labels.");
				throw new WellDefinitionException("Lower case Labeled value " + entry + " of edge " + e.getName() + " does not subsume the endpoint labels.",
						WellDefinitionException.Type.LabelNotSubsumes);
			}
		}
		return true;
	}

	/**
	 * Checks whether the label of a node satisfies the well definition 2 property:<br>
	 * for each literal present in the label:<br>
	 * 1) the label of the observation node of the considered literal is subsumed by the label of the current node.<br>
	 * 2) the observation node is constrained to occur before the current node.
	 * 
	 * @param g the current graph containing the node.
	 * @param node the current node to check.
	 * @return false if the check fails, true otherwise
	 * @throws WellDefinitionException
	 */
	static boolean checkWellDefinition2Property(Graph g, Node node) throws WellDefinitionException {
		if (g == null || node == null) {
			CSTNU.LOG.warning("One parameter is null at least. Please, check parameter.");
			return false;
		}

		Label nodeLabel = node.getLabel();
		if (nodeLabel.equals(Label.emptyLabel)) return true;

		// check the observation node
		for (final Literal l : nodeLabel.getAllStraight()) {
			Node obs = g.getObservable(l);

			if (obs == null) {
				CSTNU.LOG.warning("Observation node of literal " + l + " of node " + node + " does not exist.");
				throw new WellDefinitionException("Observation node of literal " + l + " of node " + node + " does not exist.",
						WellDefinitionException.Type.ObservationNodeDoesNotExist);
			}

			Label obsLabel = obs.getLabel();
			if (!nodeLabel.subsumes(obsLabel)) {
				CSTNU.LOG.warning("Label of node " + node + " does not subsume label of obs node " + obs);
				throw new WellDefinitionException("Label of node " + node + " does not subsume label of obs node " + obs,
						WellDefinitionException.Type.LabelNotSubsumes);
			}

			Edge e = g.findEdge(node, obs);
			if (e == null || e.getMinValue() == null || e.getMinValue() > 0) {
				CSTNU.LOG.warning("There is no constraint to execute obs node " + obs + " before node " + node);
				throw new WellDefinitionException("There is no constraint to execute obs node " + obs + " before node " + node,
						WellDefinitionException.Type.ObservationNodeDoesNotOccurBefore);
			}
		}
		return true;
	}

	/**
	 * Checks whether any labeled value of a edge satisfies the well definition 3 property:<br>
	 * for each literal present in any label of e:<br>
	 * 1) the label of the observation node of the considered literal is subsumed by the label of the edge.<br>
	 * 
	 * @param g the current graph containing the node.
	 * @param e the current edge to check.
	 * @return false if the check fails, true otherwise
	 * @throws WellDefinitionException
	 */
	static boolean checkWellDefinition3Property(Graph g, Edge e) throws WellDefinitionException {
		if (g == null || e == null) {
			CSTNU.LOG.warning("One parameter is null at least. Please, check parameter.");
			return false;
		}

		Set<Entry<Entry<Label, String>, Integer>> allLabeledValuesSet = e.getAllUpperCaseAndOrdinaryLabeledValuesSet();
		allLabeledValuesSet.addAll(e.getLowerLabelSet());
		for (Entry<Entry<Label, String>, Integer> entry : allLabeledValuesSet) {
			Label edgeLabel = entry.getKey().getKey();
			if (edgeLabel.equals(Label.emptyLabel)) continue;

			// check the observation node
			for (final Literal l : edgeLabel.getAllStraight()) {
				Node obs = g.getObservable(l);

				if (obs == null) {
					CSTNU.LOG.warning("Observation node of literal " + l + " present in label " + edgeLabel + " of edge " + e + " does not exist.");
					throw new WellDefinitionException("Observation node of literal " + l + " present in label " + edgeLabel + " of edge " + e
							+ " does not exist.",
							WellDefinitionException.Type.ObservationNodeDoesNotExist);
				}

				Label obsLabel = obs.getLabel();
				if (!edgeLabel.subsumes(obsLabel)) {
					CSTNU.LOG.warning("Label " + edgeLabel + " of edge " + e + " does not subsume label of obs node " + obs);
					throw new WellDefinitionException("Label " + edgeLabel + " of edge " + e + " does not subsume label of obs node " + obs,
							WellDefinitionException.Type.LabelNotSubsumes);
				}
			}
		}
		return true;
	}

	/**
	 * @param g
	 * @return true if the g is a CSTNU well defined.
	 * @throws WellDefinitionException
	 */
	static boolean checkWellDefinitionProperties(Graph g) throws WellDefinitionException {
		boolean flag = false;
		CSTNU.LOG.info("Checking if graph is well defined...");
		for (Edge e : g.getEdges()) {
			flag = checkWellDefinition1Property(g.getSource(e), g.getDest(e), e);
			flag = flag && checkWellDefinition3Property(g, e);
		}
		for (Node node : g.getNodes()) {
			flag = flag && checkWellDefinition2Property(g, node);
		}
		CSTNU.LOG.info(((flag) ? "done: all is well defined.\n" : "done: something is wrong. Not well defined graph!\n"));
		return flag;
	}

	/**
	 * Apply Morris Label Removal Reduction (see page 1196 of the article MM2005).
	 * 
	 * <pre>
	 *     l_1, b, x    l_2, B, z                    l_1 l_2, z
	 * B  <---------A <----------C and z>=-x adds A <-----------C
	 * </pre>
	 * 
	 * @param currentGraph the originating graph.
	 * @param nextGraph the graph where to write the new constraints.
	 * @return true if a reduction is applied at least
	 */
	static boolean caseLabelRemovalRule(Graph currentGraph, Graph nextGraph) {
		if ((currentGraph == null) || (nextGraph == null)) {
			CSTNU.LOG.info("One parameter is null. Game over");
			return false;
		}

		CSTNU.LOG.finer("Label Removal Rule: start.");
		final Set<Edge> lowerCaseEdge = currentGraph.getLowerLabeledEdges();
		/*
		 * I use the same node/edge ids of the Morris paper: A, B, C for nodes, and CA, AB for edges.
		 */
		Node A, B;
		boolean reductionApplied = false;
		Set<Entry<Entry<Label, String>, Integer>> ABMap;

		for (final Edge AB : lowerCaseEdge) {
			ABMap = AB.getLowerLabelSet();
			if (ABMap.size() == 0) continue;
			A = currentGraph.getSource(AB);
			B = currentGraph.getDest(AB);

			final Set<Edge> CAEdgesWithUpperCaseLabel = new HashSet<>();
			for (final Edge e : currentGraph.getInEdges(A))
				if ((e.getUpperLabelSet().size() > 0) && !currentGraph.getSource(e).equalsByName(B))
					CAEdgesWithUpperCaseLabel.add(e);

			for (final Edge CA : CAEdgesWithUpperCaseLabel) {
				final Edge CAInNext = nextGraph.findEdge(nextGraph.getNode(currentGraph.getSource(CA).getName()),
						nextGraph.getNode(currentGraph.getDest(CA).getName()));
				if (CAInNext == null) throw new IllegalArgumentException("The edge CAInNext cannot be null!");
				for (final Entry<Entry<Label, String>, Integer> upperCaseEntryOfCA : CA.getUpperLabelSet()) {
					final String upperCaseNodeName = upperCaseEntryOfCA.getKey().getValue();
					if (!upperCaseNodeName.equals(B.getName())) continue;// Rule rules!
					final Label l2 = upperCaseEntryOfCA.getKey().getKey();
					final Integer z = upperCaseEntryOfCA.getValue();

					for (final Entry<Entry<Label, String>, Integer> lowerCaseEntryOfAB : ABMap) {
						final Integer x = lowerCaseEntryOfAB.getValue();
						if (z < -x) continue;
						final Label l1 = lowerCaseEntryOfAB.getKey().getKey();
						final Label l1l2 = l1.conjunction(l2);
						if (l1l2 == null) continue;
						if (!l2.subsumes(l1))
							CSTNU.LOG.finer("Luke's curiosity: the Upper Case label removal on entry "
									+ upperCaseEntryOfCA + " of edge " + CA.getName() + " is applied with label "
									+ l1l2 + " because " + l2 + " does not subsume " + l1);
						final Integer oldZ = CAInNext.getValue(l1l2);
						final String oldCA = CA.toString();

						if (CAInNext.mergeLabeledValue(l1l2, z)) {
							reductionApplied = true;
							CSTNU.LOG.finer("Case Label Removal applied to edge " + oldCA + ":\n"
									+ "partic: " + B.getName() + " <---(" + l1 + ", " + lowerCaseEntryOfAB.getKey().getValue().toLowerCase() + ", " + x
									+ ")--- " + A.getName() + " <---(" + l2 + ", " + upperCaseNodeName.toUpperCase() + ", " + z + ")--- "
									+ currentGraph.getSource(CA).getName()
									+ "\nresult: " + A.getName() + " <---(" + l1l2 + ", " + Constants.EMPTY_UPPER_CASE_LABEL_STRING + ", " + z + ")--- "
									+ currentGraph.getSource(CA).getName()
									+ "; oldValue: " + oldZ);
							if (!z.equals(oldZ)) CSTNU.LOG.finer("Edge " + CA.getName() + " after the rule: " + CA.toString());
						}
					}
				}
			}
		}
		CSTNU.LOG.finer("Label Removal Rule: end.");
		return reductionApplied;
	}

	/**
	 * Apply Morris cross case reduction (see page 1196 of the article).
	 * 
	 * <pre>
	 *      l1, B:x        l2, c:y                          l1l2, B:x+y
	 * A  <-----------C <----------D and x<=0, B!=C adds A <-------------D
	 * </pre>
	 * 
	 * @param currentGraph the originating graph.
	 * @param nextGraph the graph where to write the new constraints.
	 * @return true if a reduction is applied at least
	 */
	static boolean crossCaseRule(Graph currentGraph, Graph nextGraph) {
		if ((currentGraph == null) || (nextGraph == null)) {
			CSTNU.LOG.info("One parameter is null. Game over");
			return false;
		}

		final Set<Edge> lowerCaseEdges = currentGraph.getLowerLabeledEdges();
		/*
		 * I use the same node/edge ids of the Morris paper: A, C, D for nodes, and CA, DC, and DA for edges.
		 */
		Node A, C, D;
		Edge DA;
		boolean reductionApplied = false;
		Set<Entry<Entry<Label, String>, Integer>> DCMap;

		CSTNU.LOG.finer("Cross Case Rule: start.");
		for (final Edge DC : lowerCaseEdges) {
			DCMap = DC.getLowerLabelSet();
			if (DCMap.size() == 0) continue;
			D = currentGraph.getSource(DC);
			C = currentGraph.getDest(DC);

			// Select only Upper Case edges from C and containing one negative value at least (in the following it is
			// necessary to check that Upper Label different from C
			final Set<Edge> upperCaseEdgeFromC = new HashSet<>();
			Integer v;
			for (final Edge e : currentGraph.getOutEdges(C))
				if (((v = e.getMinUpperLabeledValue()) != null) && (v <= 0)) upperCaseEdgeFromC.add(e);

			for (final Edge upperCaseEdge : upperCaseEdgeFromC) {
				A = currentGraph.getDest(upperCaseEdge);

				for (final Entry<Entry<Label, String>, Integer> entryLabelUpperCaseEdge : upperCaseEdge.getUpperLabelSet()) {
					final String upperCaseNodeName = entryLabelUpperCaseEdge.getKey().getValue();
					if (upperCaseNodeName.equals(C.getName())) continue;// Rule rule!
					final Integer x = entryLabelUpperCaseEdge.getValue();
					if (x > 0) continue; // Rule rule!
					final Label l1 = entryLabelUpperCaseEdge.getKey().getKey();

					DA = nextGraph.findEdge(nextGraph.getNode(D.getName()), nextGraph.getNode(A.getName()));
					for (final Entry<Entry<Label, String>, Integer> entryLowerCaseEdgeToC : DCMap) {
						final Integer y = entryLowerCaseEdgeToC.getValue();
						final Label l2 = entryLowerCaseEdgeToC.getKey().getKey();
						final Label l1l2 = l1.conjunction(l2);
						if (l1l2 == null) continue;
						if (DA == null) {
							DA = new Edge("e" + D.getName() + A.getName(), Edge.Type.derived);
							nextGraph.addEdge(DA, nextGraph.getNode(D.getName()), nextGraph.getNode(A.getName()));
							// nextGraph.addUpperLabeledEdge(DA);
							LOG.finer("crossCaseRule: added edge " + DA.getName());

						}
						final Integer z = x + y;
						final Integer oldZ = DA.getUpperLabelValue(l1l2, upperCaseNodeName);
						final String oldDA = DA.toString();

						if (DA.mergeUpperLabelValue(l1l2, upperCaseNodeName, z)) {
							reductionApplied = true;
							CSTNU.LOG.finer("Cross Case applied to edge " + oldDA
									+ ":\n partic: " + A.getName() + " <---(" + l1 + ", " + upperCaseNodeName.toUpperCase() + ", " + x + ")--- " + C.getName()
									+ " <---(" + l2 + ", " + entryLowerCaseEdgeToC.getKey().getValue().toLowerCase() + ", " + y + ")--- " + D.getName()
									+ "\nresult: " + A.getName() + " <---(" + l1l2 + ", " + upperCaseNodeName.toUpperCase() + ", " + z + ")--- " + D.getName()
									+ "; oldValue: " + oldZ);
							if (!z.equals(oldZ)) CSTNU.LOG.finer("Edge " + DA.getName() + " after the ruel: " + DA.toString());

						}
					}
				}
			}
		}
		CSTNU.LOG.finer("Cross Case Rule: end.");
		return reductionApplied;
	}

	/**
	 * Checks the controllability of a CSTNU instance and, if the instance is controllable, determines all the minimal
	 * ranges for the constraints. <br>
	 * All label containing proposition that cannot be evaluated at run time are removed.
	 * 
	 * @param g the original graph that has to be checked. If the check is successful, g is modified and it contains all
	 *            minimized constraints; otherwise, it is not modified.
	 * @param instantaneousReaction
	 * @return true the graph is dynamically controllable, false otherwise.
	 * @throws WellDefinitionException if the nextGraph is not well defined (does not observe all well definition properties). If this exception occurs, then
	 *             there is a problem in the rules coding.
	 */
	static public boolean dynamicControllabilityCheck(Graph g, boolean instantaneousReaction) throws WellDefinitionException {
		if (g == null) return false;

		Graph currentGraph, nextGraph, distanceGraph;
		currentGraph = new Graph(g);
		try {
			CSTNU.initUpperLowerLabelDataStructure(currentGraph);
		}
		catch (IllegalArgumentException e) {
			throw new IllegalArgumentException("The graph has a problem and it cannot be initialize: " + e.getMessage());
		}
		final int n = currentGraph.getVertexCount();
		int k = currentGraph.getUpperLabeledEdges().size();
		if (k == 0) k = 1;
		int p = currentGraph.getPropositions().size();
		if (p == 0) p = 1;
		int i;

		Entry<Boolean, Boolean> status;
		nextGraph = new Graph(currentGraph);
		distanceGraph = new Graph();
		boolean reductionsApplied = false;
		boolean inconsistency = false;

		// I reset all counters
		R0calls = R1calls = R2calls = R3calls = R4calls = R5calls = R6calls = NoCaseLabelcalls = ObsCaseRule = 0;

		// final int maxCycles = p * ((n * n) + (n * k) + k);//cstnu
		// int maxCycles = (int) (Math.pow(2,p) * Math.pow(n, 3) * -getSumOfNegativeEdgeValues(g) );//cstn
		int maxCycles = -getSumOfNegativeEdgeValues(g)*n;// cstn
		if (maxCycles == 0) maxCycles = 2;
		CSTNU.LOG.info("The maximum number of possible cycles is " + maxCycles);

		// final int maxCycles = Integer.MAX_VALUE;
		for (i = 1; i <= maxCycles; i++) {
			CSTNU.LOG.info("*** Start Cycle " + i + "/" + maxCycles + " ***");
			status = oneStepDynamicControllability(i, currentGraph, nextGraph, distanceGraph, instantaneousReaction);
			reductionsApplied = status.getKey();
			inconsistency = status.getValue();

			if (inconsistency) {
				CSTNU.LOG.finer("Final inconsistent graph: " + nextGraph);
				return false;
			}
			if (!reductionsApplied) {
				break;
			}
			CSTNU.LOG.info("*** End Cycle " + i + "/" + maxCycles + " ***\n\n");
			currentGraph.clone(nextGraph);
		}

		CSTNU.LOG.info("Rule R0 has been applied " + R0calls + " times.\n"
				+ "Rule R1 has been applied " + R1calls + " times.\n"
				+ "Rule R2 has been applied " + R2calls + " times.\n"
				+ "Rule R3 has been applied " + R3calls + " times.\n"
				+ "Rule R4 has been applied " + R4calls + " times.\n"
				+ "Rule R5 has been applied " + R5calls + " times.\n"
				+ "Rule R6 has been applied " + R6calls + " times.\n"
				+ "Rule ObsCaseRule has been applied " + ObsCaseRule + " times.\n"
				+ "Rule NoCaseLabel has been applied " + NoCaseLabelcalls + " times.\n"
				);

		if (i > maxCycles) {
			CSTNU.LOG.info("The maximum number of cycle (+" + maxCycles + ") has been reached: stop!\n");
			CSTNU.LOG.finer("Final inconsistent graph: " + nextGraph);
			return false;
		}
		CSTNU.LOG.info("Stable state reached. Number of minimization cycles: " + i + " over the maximum allowed " + maxCycles);
		// Put all data structures of currentGraph in g
		currentGraph.clone(nextGraph);// try to remove all redundant labeled values.
		g.takeIn(currentGraph);
		return true;
	}

	/**
	 * Checks the dynamic consistency of a CSTN instance and, if the instance is consistent, determines all the minimal
	 * ranges for the constraints. <br>
	 * All label containing proposition that cannot be evaluated at run time are removed.
	 * 
	 * @param g the original graph that has to be checked. If the check is successful, g is modified and it contains all
	 *            minimized constraints; otherwise, it is not modified.
	 * @param instantaneousReactions true is it is admitted that observation points and other points depending from the observed proposition can be executed
	 *            in the same 'instant'.
	 * @return true the graph is dynamically consistent, false otherwise.
	 * @throws WellDefinitionException if the nextGraph is not well defined (does not observe all well definition properties). If this exception occurs, then
	 *             there is a problem in the rules coding.
	 */
	static public boolean dynamicConsistencyCheck(Graph g, boolean instantaneousReactions) throws WellDefinitionException {
		if (g == null) return false;

		Graph currentGraph, nextGraph, distanceGraph;
		currentGraph = new Graph(g);
		try {
			CSTNU.initUpperLowerLabelDataStructure(currentGraph);
		}
		catch (IllegalArgumentException e) {
			throw new IllegalArgumentException("The graph has a problem and it cannot be initialize: " + e.getMessage());
		}
		final int n = currentGraph.getVertexCount();
		int k = currentGraph.getUpperLabeledEdges().size();
		if (k == 0) k = 1;
		int p = currentGraph.getPropositions().size();
		if (p == 0) p = 1;
		int i;

		Entry<Boolean, Boolean> status;
		nextGraph = new Graph(currentGraph);
		distanceGraph = new Graph();
		boolean reductionsApplied = false;
		boolean inconsistency = false;

		// I reset all counters
		R0calls = R1calls = R2calls = R3calls = R4calls = R5calls = R6calls = NoCaseLabelcalls = ObsCaseRule = 0;

		// final int maxCycles = p * ((n * n) + (n * k) + k);//cstnu
		// int maxCycles = (int) (Math.pow(2,p) * Math.pow(n, 3) * -getSumOfNegativeEdgeValues(g) );//cstn
		int maxCycles = -getSumOfNegativeEdgeValues(g)*n;// cstn
		if (maxCycles == 0) maxCycles = 2;
		CSTNU.LOG.info("The maximum number of possible cycles is " + maxCycles);

		// final int maxCycles = Integer.MAX_VALUE;
		for (i = 1; i <= maxCycles; i++) {
			CSTNU.LOG.info("*** Start Cycle " + i + "/" + maxCycles + " ***");
			status = oneStepDynamicConsistency(i, currentGraph, nextGraph, distanceGraph, instantaneousReactions);
			reductionsApplied = status.getKey();
			inconsistency = status.getValue();

			if (inconsistency) {
				CSTNU.LOG.finer("Final inconsistent graph: " + nextGraph);
				return false;
			}
			if (!reductionsApplied) {
				break;
			}
			CSTNU.LOG.info("*** End Cycle " + i + "/" + maxCycles + " ***\n\n");
			currentGraph.clone(nextGraph);
		}

		CSTNU.LOG.info("Rule R0 has been applied " + R0calls + " times.\n"
				+ "Rule R1 has been applied " + R1calls + " times.\n"
				+ "Rule R2 has been applied " + R2calls + " times.\n"
				+ "Rule R3 has been applied " + R3calls + " times.\n"
				+ "Rule R4 has been applied " + R4calls + " times.\n"
				+ "Rule R5 has been applied " + R5calls + " times.\n"
				+ "Rule R6 has been applied " + R6calls + " times.\n"
				+ "Rule ObsCaseRule has been applied " + ObsCaseRule + " times.\n"
				+ "Rule NoCaseLabel has been applied " + NoCaseLabelcalls + " times.\n"
				);

		if (i > maxCycles) {
			CSTNU.LOG.info("The maximum number of cycle (+" + maxCycles + ") has been reached: stop!\n");
			CSTNU.LOG.finer("Final inconsistent graph: " + nextGraph);
			return false;
		}
		CSTNU.LOG.info("Stable state reached. Number of minimization cycles: " + i + " over the maximum allowed " + maxCycles);
		// Put all data structures of currentGraph in g
		currentGraph.clone(nextGraph);// try to remove all redundant labeled values.
		g.takeIn(currentGraph);
		return true;
	}

	/**
	 * Simple method to determine the three parts of labels as required by lemma R1 and R2.<br>
	 * Label[0] is the sublabel of labelEdgeFromP not in common with labelWithoutP.<br>
	 * Label[1] is the sublabel of labelEdgeFromP in common with labelWithoutP.<br>
	 * Label[2] is the sublabel of labelWithoutP not in common with labelEdgeFromP.
	 * 
	 * @param labelEdgeFromP
	 * @param labelWithoutP
	 * @return an array of three labels as required by lemma R1 and R2.
	 */
	private static Label[] getAlphaBetaGamma(Label labelEdgeFromP, Label labelWithoutP) {
		final Label[] alphaBetaGamma = new Label[3];
		alphaBetaGamma[0] = labelEdgeFromP.subLabelFrom(labelWithoutP, false);
		alphaBetaGamma[1] = labelEdgeFromP.subLabelFrom(labelWithoutP, true);
		alphaBetaGamma[2] = labelWithoutP.subLabelFrom(labelEdgeFromP, false);

		return alphaBetaGamma;
	}

	/**
	 * @param gamma the original gamma
	 * @param p the literal
	 * @param g the graph where there are the observation nodes of propositions.
	 * @return gamma' that contains only the literals of gamma having observation nodes that do not depend by literal p. Null if any parameter is null.
	 */
	private static Label getGammaCleaned(Label gamma, Literal p, Graph g) {
		if (gamma == null || p == null || g == null) return null;
		Label gamma1 = new Label();
		for (Literal l : gamma.getAll()) {
			Node obs = g.getObservable(l);
			LOG.finest("Observation for " + l + " in gamma: " + obs);
			Label obsLabel = obs.getLabel();
			LOG.finest("Label for " + obs.getName() + ": " + obsLabel);

			if ((!obsLabel.contains(p) && !obsLabel.contains(p.negation()))) {
				gamma1.conjunct(l);
			}
			LOG.finest("Gamma1 update to:" + gamma1);
		}
		return gamma1;
	}

	/**
	 * @param alpha
	 * @param g
	 * @return Null if any parameter is null.
	 */
	@SuppressWarnings("unused")
	private static Set<Label> getNotAlpha(Label alpha, Graph g) {
		if (alpha == null || g == null) return null;
		HashSet<Label> labelSet = new HashSet<>();

		Collection<Literal> allLiteral = alpha.getAll();
		for (Literal l : allLiteral) {
			Label alphaLabel = new Label(l.negation());
			Label obsLabel = g.getObservable(l).getLabel();
			for (Literal l1 : allLiteral) {
				if (l1.equals(l)) continue;
				if (obsLabel.contains(l1))
					alphaLabel.conjunct(l1);
			}
			labelSet.add(alphaLabel);
		}
		return labelSet;
	}

	/**
	 * For each contingent edge, initialize the upper and the lower labeled maps.<br>
	 * Such method has to be called before the call of {@link #dynamicControllabilityCheck(Graph, boolean))}.<br>
	 * In order to maintain a minimal structure, we assume that a contingent edge is always in pair with an inverted
	 * one. Otherwise, an exception is thrown. Moreover, we assume that, given a pair of contingent edges between two
	 * nodes (one for lower bound and the other for the upper one), the lower is always less or equal to 0, the upper is
	 * always greater than 0.<br>
	 * Moreover, this method determines the set of propositions observed in the graph.
	 * 
	 * @param g
	 * @return true. If there is any problem, it throws an exception saying the error.
	 * @throws IllegalArgumentException if the graph is null or it not contains Z node or it is not well formed.
	 */
	@SuppressWarnings("javadoc")
	static boolean initUpperLowerLabelDataStructure(Graph g) throws IllegalArgumentException {
		if (g == null) throw new IllegalArgumentException("The graph is null!");

		g.cleanLowerEdgeCache();
		g.cleanPropositionCache();

		Set<Edge> edgeSet = new HashSet<>(g.getEdges());
		for (Edge e : edgeSet) {

			// Sanity check for the label:
			// set one label if endpoints have one and edge no.
			// set the default label for each edge.

			// WD1 is checked and adjusted here
			final Node s = g.getSource(e);
			final Node d = g.getDest(e);
			final Label conjunctLabel = s.getLabel().conjunction(d.getLabel());
			// CSTNU.LOG.finest("source label: " + s.getLabel() + "; dest label: " + d.getLabel() + " new label: " + l);

			if (conjunctLabel == null) {
				CSTNU.LOG.warning("Found a inconsistent label between two nodes connected by an edge. Edge removed!");
				g.removeEdge(e);
				continue;
			}
			final Integer initialValue = e.getInitialValue();
			// final String caseLabel = e.getInitialCaseLabel();
			if (initialValue != null) {
				// CSTNU.LOG.finest("New labeled value for " + e.getName() + ": (" + l + ", " + initialValue + ")");
				e.mergeLabeledValue(conjunctLabel, initialValue);
			}

			if (e.size() == 0) {
				// The merge removed labels...
				g.removeEdge(e);
				continue;
			}
			// now I can check the WD3 property
			try {
				checkWellDefinition3Property(g, e);
			}
			catch (WellDefinitionException ex) {
				throw new IllegalArgumentException("Edge " + e + " has the following problem: " + ex.getMessage());
			}

			if (!e.isContingentEdge()) continue;

			/***
			 * Manage contingent link
			 * 
			 * In svn version 74 I try to introduce the management of guarded link (contingent link with different paired requirement constraints).
			 * The initial value is the requirement value.
			 */
			// we consider only the initial value.
			if (initialValue == null)
				throw new IllegalArgumentException("Contingent edge cannot be inizialized because default initial value is null.");

			// e.clearLabels();

			// if (caseLabel != null) {
			// // manage a wait contingent link
			// if (caseLabel.matches(Constants.upperCaseLabel)) {
			// e.mergeUpperLabelValue(l, caseLabel, initialValue);
			// } else {
			// CSTNU.LOG.warning("Contingent edge with a wait default label that is lower case!");
			// e.mergeLowerLabelValue(l, caseLabel, initialValue);
			// }
			// continue;
			// }

			Edge eInverted = g.findEdge(d, s);
			if (eInverted == null) {
				eInverted = new Edge("e" + d.getName() + s.getName(), Edge.Type.derived);
				g.addEdge(eInverted, d, s);
			} else {
				// eInverted.clearLowerLabels();
				// eInverted.clearUpperLabels();
			}
			// e.mergeLabeledValue(conjunctLabel, initialValue);
			// if (initialValue <= 0)
			// eInverted.mergeLowerLabelValue(conjunctLabel, s, -initialValue);
			// else
			// eInverted.mergeUpperLabelValue(conjunctLabel, d, -initialValue);
		}
		// init usefull structures
		g.getLowerLabeledEdges();
		g.getPropositions();

		// Now node checking!
		Set<Node> nodeSet = new HashSet<>(g.getVertices());
		for (Node node : nodeSet) {

			if (g.Z == null && isZ(node)) g.Z = node;// FIXME Fai in modo che l'utente possa dire chi è il nodo Z.

			// Check that obs-node has no in its label the proposition observed!
			Literal obs = node.getObservable();
			Label label = node.getLabel();
			if (obs != null) {
				if (label.contains(obs)) {
					throw new IllegalArgumentException("Literal '" + obs + "' cannot be part of the label '" + label + "' of node '" + node.getName() + "'.");
				}
			}

			try {
				checkWellDefinition2Property(g, node);
			}
			catch (WellDefinitionException ex) {
				if (ex.getType() == Type.ObservationNodeDoesNotOccurBefore) {
					for (Literal l1 : label.getAllStraight()) {
						Node obsl1 = g.getObservable(l1);
						Edge e = g.findEdge(node, obsl1);
						if (e == null) {
							e = new Edge("e" + node.getName() + obsl1.getName(), Edge.Type.derived);
							g.addEdge(e, node, obsl1);
							CSTNU.LOG.warning("It is necessary to add a preceding constraint between node '" + node.getName() + "' and node '"
									+ obsl1.getName() + "' to satisfy WD2.");
						}
						e.mergeLabeledValue(label, 0);
					}
				} else
					throw new IllegalArgumentException(ex.getMessage());
			}
		}

		Node Z = g.Z;
		if (Z == null) {
			throw new IllegalArgumentException("In the graph there is no Z node. Fix it!");
		}
		if (!Z.getLabel().isEmpty()) {
			throw new IllegalArgumentException("In the graph, Z node has not empty label. Fix it!");
		}

		// Now I assuring that each node has a edge to Z.
		for (Node node : nodeSet) {
			if (node == Z) continue;
			Edge e = g.findEdge(node, Z);
			if (e == null) {
				e = new Edge("e" + node.getName() + Z.getName(), Edge.Type.derived);
				g.addEdge(e, node, Z);
				CSTNU.LOG.warning("It is necessary to add a preceding constraint between node '" + node.getName() + "' and node '"
						+ Z.getName() + "' because Z must be the first node.");
			}
			e.mergeLabeledValue(node.getLabel(), 0);// in any case, all nodes must be after Z!
		}

		return true;
	}

	/**
	 * Applies rule R0, R2 and R4: label containing a proposition that can be decided only in the future, is simplified
	 * removing such proposition.
	 * 
	 * <pre>
	 * R0:
	 * P? --[a p,U,-w]--&gt; X changes in P? --[a,U,-w]--&gt; X when w &lt;0
	 * 
	 * R2:
	 * P? &lt;--[a p,U,w]-- X  changes in P? &lt;--[a,U,w]-- X when w &gt; 0
	 * 
	 * R4:
	 * P? &lt;--[a p,U,w]-- X  changes in P? &lt;--[a,U,0][a p,U,w]-- X when w &le; 0
	 * 
	 * where:
	 * U can be ◇ or an upper letter.
	 * p can be the positive o the negative literal associated to proposition observed in P?.
	 * </pre>
	 * 
	 * @param currentGraph
	 * @param instantaneousReaction true is it is admitted that observation points and other points depending from the observed proposition can
	 *            be executed in the same 'instant'.
	 * 
	 * @return true if the rule has been applied one time at least.
	 */
	static boolean labelModificationR0R2R4(Graph currentGraph, boolean instantaneousReaction) {

		boolean ruleApplied = false;
		final Map<Literal, Node> obsMap = currentGraph.getObservables();
		if (obsMap == null) return false;
		final Collection<Node> obsNodes = obsMap.values();

		Literal p;
		Collection<Edge> outEdges, inEdges;
		CSTNU.LOG.finer("Label Modification R0, R2 and R4: start.");
		for (final Node obsNode : obsNodes) {
			p = obsNode.getObservable();

			// R0 rule
			outEdges = currentGraph.getOutEdges(obsNode);
			Node destNode = null;
			for (final Edge edge : outEdges) {
				boolean r0Applied = false;
				// ordinary labels
				destNode = currentGraph.getDest(edge);
				final Set<Entry<Label, Integer>> edgeLabeledValueSet = new HashSet<>(edge.labeledValueSet());
				for (final Entry<Label, Integer> entryObs : edgeLabeledValueSet) {
					final Integer w = entryObs.getValue();
					if (w > 0 || (instantaneousReaction && w == 0)) continue;

					final Label l = entryObs.getKey();
					if (edge.getValue(l) == null) continue;// it is possible that in a previous cycle the label has been removed.
					if (!l.contains(p) && !l.contains(p.negation())) continue;

					final Label labelWithouP = new Label(l);
					labelWithouP.remove(p);
					labelWithouP.remove(p.negation());

					// if (!checkNodeLabelsSubsumption(obsNode, destNode, labelWithouP, edge.getName(), "R0")) {
					// // It means that 'X' label contains 'p', but node 'X' must occur before P? => graph not well defined!
					// final String msg = "Rule R0: new label does not subsume labels of P? and X. It means that P? or X label contains 'p'." +
					// "\n***This is not possible. Graph not well formed.***";
					// CSTNU.LOG.severe(msg);
					// throw new IllegalStateException(msg);
					// }

					// Prepare the log message now with old values of the edge. If R0 modifies, then we can log it correctly.
					String logMessage = "R0 adds a label to edge " + edge
							+ ":\npartic: " + destNode.getName() + " <---(" + l + ", " + Constants.EMPTY_UPPER_CASE_LABEL_STRING + ", " + w + ")--- "
							+ obsNode.getName()
							+ "\nresult: " + destNode.getName() + " <---(" + labelWithouP + ", " + Constants.EMPTY_UPPER_CASE_LABEL_STRING + ", " + w
							+ ")--- " + obsNode.getName();

					edge.putLabeledValueToRemovedList(l, w);
					edge.removeLabel(l);
					R0calls++;
					r0Applied = true;
					if (edge.mergeLabeledValue(labelWithouP, w)) {
						CSTNU.LOG.finer(logMessage);
					}
				}

				// upper-case labels
				final Set<Entry<Entry<Label, String>, Integer>> edgeUpperLabeledValueSet = new HashSet<>(edge.getUpperLabelSet());
				for (final Entry<Entry<Label, String>, Integer> entryObs : edgeUpperLabeledValueSet) {
					final Integer w = entryObs.getValue();
					if (w > 0 || (instantaneousReaction && w == 0)) continue;

					final Label l = entryObs.getKey().getKey();

					final String nodeName = entryObs.getKey().getValue();
					if (edge.getUpperLabelValue(l, nodeName) == null) continue;// it is possible that in a previous cycle the label has been removed.
					if (!l.contains(p) && !l.contains(p.negation())) continue;

					final Label labelWithouP = new Label(l);
					labelWithouP.remove(p);
					labelWithouP.remove(p.negation());

					// if (!checkNodeLabelsSubsumption(obsNode, destNode, labelWithouP, edge.getName(), "R0")) {
					// // It means that 'X' label contains 'p', but node 'X' must occur before P? => graph not well defined!
					// final String msg = "Rule R0: new label does not subsume labels of P? and X. It means that P? or X label contains 'p'." +
					// "\n***This is not possible. Graph not well formed.***";
					// CSTNU.LOG.severe(msg);
					// throw new IllegalStateException(msg);
					// }

					// Prepare the log message now with old values of the edge. If R0 modifies, then we can log it correctly.
					String logMessage = "R0 adds a label to edge " + edge
							+ ":\npartic: " + destNode.getName() + " <---(" + l + ", " + nodeName + ", " + w + ")--- " + obsNode.getName()
							+ "\nresult: " + destNode.getName() + " <---(" + labelWithouP + ", " + nodeName + ", " + w + ")--- " + obsNode.getName();

					edge.removeUpperLabel(l, nodeName);
					edge.putUpperLabeledValueToRemovedList(l, nodeName, w);
					R0calls++;
					r0Applied = true;
					if (edge.mergeUpperLabelValue(labelWithouP, nodeName, w)) {
						CSTNU.LOG.finer(logMessage);
					}
				}
				if (r0Applied) {
					CSTNU.LOG.finer("Edge " + edge.getName() + " after the rule R0: " + edge.toString());
					ruleApplied = true;
				}
			}

			// R2 & R4 rule
			inEdges = currentGraph.getInEdges(obsNode);
			for (final Edge edgeInModification : inEdges) {
				// CSTNU.LOG.finer("R2 to be applied to edge " + edge.getName() + ": "+edge.toString());

				Node sourceNode = currentGraph.getSource(edgeInModification);
				boolean r2Applied = false, r4Applied = false;
				// destNode == obsNode;
				// ordinary labels
				final Set<Entry<Label, Integer>> edgeLabeledValueSet = new HashSet<>(edgeInModification.labeledValueSet());
				for (final Entry<Label, Integer> entryObs : edgeLabeledValueSet) {
					final Integer w = entryObs.getValue();
					final Label l = entryObs.getKey();

					if (edgeInModification.getValue(l) == null) continue;// it is possible that in a previous cycle the label has been
					// removed thanks to label optimization.
					if (!l.contains(p) && !l.contains(p.negation())) continue;

					final Label labelWithouP = new Label(l);
					labelWithouP.remove(p);
					labelWithouP.remove(p.negation());

					if (w > 0) {
						// R2 rule
						if (!checkNodeLabelsSubsumption(sourceNode, obsNode, labelWithouP, edgeInModification.getName(), "R2")) {
							// It means that 'X' label contains 'p'!
							// The labeled value has to be substituted by a 0 labeled value because by WD2 the node ha to be after the observation node.
							CSTNU.LOG.finer("Details about subsumption check of R2 applied to edge " + edgeInModification
									+ ":\npartic: "
									+ obsNode.getName() + " <---(" + l + ", " + Constants.EMPTY_UPPER_CASE_LABEL_STRING + ", " + w + ")--- "
									+ sourceNode.getName()
									+ "\nresult: "
									+ obsNode.getName() + " <---(" + sourceNode.getLabel().conjunction(obsNode.getLabel()) + ", "
									+ Constants.EMPTY_UPPER_CASE_LABEL_STRING + ", 0)--- "
									+ sourceNode.getName());

							edgeInModification.mergeLabeledValue(l, 0);
							continue;
						}

						// Prepare the log message now with old values of the edge. If R2 modifies, then we can log it correctly.
						String logMessage = "R2 adds a labels to edge " + edgeInModification
								+ ":\npartic: "
								+ obsNode.getName() + " <---(" + l + ", " + Constants.EMPTY_UPPER_CASE_LABEL_STRING + ", " + w + ")--- "
								+ sourceNode.getName()
								+ "\nresult: "
								+ obsNode.getName() + " <---(" + labelWithouP + ", " + Constants.EMPTY_UPPER_CASE_LABEL_STRING + ", " + w + ")--- "
								+ sourceNode.getName();

						edgeInModification.putLabeledValueToRemovedList(l, w);
						edgeInModification.removeLabel(l);
						R2calls++;
						r2Applied = true;
						if (edgeInModification.mergeLabeledValue(labelWithouP, w)) {
							CSTNU.LOG.finer(logMessage);
						}
					} else {
						// w<=0
						// R4 CASE
						if (!checkNodeLabelsSubsumption(sourceNode, obsNode, labelWithouP, edgeInModification.getName(), "R4")) {
							CSTNU.LOG.finer("R4 CANNOT be applied because node label to " + edgeInModification + ": "
									+ obsNode.getName() + " <---(" + l + ", " + Constants.EMPTY_UPPER_CASE_LABEL_STRING + ", " + w + ")--- ("
									+ sourceNode.getName() + ", " + sourceNode.getLabel() + ")");
							continue;
						}

						// Prepare the log message now with old values of the edge. If R4 modifies, then we can log it correctly.
						String logMessage = "R4 adds a label to edge " + edgeInModification
								+ ":\npartic: "
								+ obsNode.getName() + " <---(" + l + ", " + Constants.EMPTY_UPPER_CASE_LABEL_STRING + ", " + w + ")--- "
								+ sourceNode.getName()
								+ "\nresult: "
								+ obsNode.getName() + " <---(" + l + ", " + Constants.EMPTY_UPPER_CASE_LABEL_STRING + ", " + w + ")"
								+ "(" + labelWithouP + ", " + Constants.EMPTY_UPPER_CASE_LABEL_STRING + ", " + 0 + ")--- " + sourceNode.getName();

						if (edgeInModification.mergeLabeledValue(labelWithouP, 0)) {
							r4Applied = true;
							R4calls++;
							CSTNU.LOG.finer(logMessage);
						}
					}
				}

				// upper-case labels
				final Set<Entry<Entry<Label, String>, Integer>> edgeUpperLabeledValueSet = new HashSet<>(edgeInModification.getUpperLabelSet());
				for (final Entry<Entry<Label, String>, Integer> entryObs : edgeUpperLabeledValueSet) {
					final Integer w = entryObs.getValue();
					final Label l = entryObs.getKey().getKey();
					final String nodeName = entryObs.getKey().getValue();
					if (edgeInModification.getUpperLabelValue(l, nodeName) == null) continue;// it is possible that in a previous
					// cycle the label has been
					// removed.
					if (!l.contains(p) && !l.contains(p.negation())) continue;

					final Label labelWithouP = new Label(l);
					labelWithouP.remove(p);
					labelWithouP.remove(p.negation());

					if (w > 0) {
						// R2 rule
						if (!checkNodeLabelsSubsumption(sourceNode, obsNode, labelWithouP, edgeInModification.getName(), "R2")) {
							// It means that 'X' label contains 'p'!
							// The labeled value has to be substituted by a 0 labeled value because by WD2 the node ha to be after the observation node.
							CSTNU.LOG.finer("Details about subsumption check of R2 to " + edgeInModification
									+ ":\npartic: "
									+ obsNode.getName() + " <---(" + l + ", " + nodeName + ", " + w + ")--- " + sourceNode.getName()
									+ "\nresult: "
									+ obsNode.getName() + " <---(" + sourceNode.getLabel().conjunction(obsNode.getLabel()) + ", " + nodeName
									+ ", 0)--- "
									+ sourceNode.getName());

							edgeInModification.removeUpperLabel(l, nodeName);
							edgeInModification.putUpperLabeledValueToRemovedList(l, nodeName, w);
							edgeInModification.mergeUpperLabelValue(sourceNode.getLabel().conjunction(obsNode.getLabel()), nodeName, 0);
						}

						// Prepare the log message now with old values of the edge. If R2 modifies, then we can log it correctly.
						String logMessage = "R2 adds a label to edge " + edgeInModification
								+ ":\n" + "partic: "
								+ obsNode.getName() + " <---(" + l + ", " + nodeName + ", " + w + ")--- " + sourceNode.getName()
								+ "\nresult: "
								+ obsNode.getName() + " <---(" + labelWithouP + ", " + nodeName + ", " + w + ")--- " + sourceNode.getName();
						edgeInModification.removeUpperLabel(l, nodeName);
						edgeInModification.putUpperLabeledValueToRemovedList(l, nodeName, w);
						R2calls++;
						r2Applied = true;
						if (edgeInModification.mergeUpperLabelValue(labelWithouP, nodeName, w)) {
							CSTNU.LOG.finer(logMessage);
						}
					} else {
						// R4 rule
						if (!checkNodeLabelsSubsumption(sourceNode, obsNode, labelWithouP, edgeInModification.getName(), "R4")) {
							CSTNU.LOG.finer("Details because R4 cannot be applied to " + edgeInModification
									+ obsNode.getName() + " <---(" + l + ", " + nodeName + ", " + w + ")--- ("
									+ sourceNode.getName() + ", " + sourceNode.getLabel() + ")");
							continue;
						}
						// Prepare the log message now with old values of the edge. If R2 modifies, then we can log it correctly.
						String logMessage = "R4 applied to edge " + edgeInModification
								+ ":\npartic: "
								+ obsNode.getName() + " <---(" + l + ", " + nodeName + ", " + w + ")--- " + sourceNode.getName()
								+ "\nresult: "
								+ obsNode.getName() + " <---(" + l + ", " + nodeName + ", " + w + ")"
								+ "(" + labelWithouP + ", " + nodeName + ", " + 0 + ")--- " + sourceNode.getName();
						if (edgeInModification.mergeUpperLabelValue(labelWithouP, nodeName, 0)) {
							CSTNU.LOG.finer(logMessage);
							R4calls++;
							r4Applied = true;
						}
					}
				}
				if (r2Applied || r4Applied) {
					CSTNU.LOG.finer("Edge " + edgeInModification.getName() + " after the rule R2R4: " + edgeInModification.toString());
					ruleApplied = true;
				}
			}
		}
		CSTNU.LOG.finer("Label Modification R0, R2 and R4: end.");
		return ruleApplied;
	}

	/**
	 * 
	 * OLD VERSION; IT DOES NOT MANAGE ALL POSSIBLE CASES
	 * Applies the Negative QStar Rules, also known as R6.<br>
	 * In this method all values are negative!
	 * Determine the less negative value (max value) among the set of negative value built considering, for each edge ObservationNode-->Z,
	 * the max negative value regardless the label (min value).
	 * 
	 * 
	 * @param currentGraph the originating graph.
	 * @param nextGraph the graph where to write the new constraints.
	 * @return true if one rule has been applied one time at least.
	 */
	// static boolean negativeQStarR6(Graph currentGraph, Graph nextGraph) {
	// if (currentGraph == null || nextGraph == null) {
	// CSTNU.LOG.info("One parameter is null. Game over");
	// return false;
	// }
	// final Map<Literal, Node> obsMap = currentGraph.getObservables();
	// if (obsMap == null) return false;
	// final Collection<Node> obsNodes = obsMap.values();
	//
	// // Check all obsNode-->Z edges and determine the less negative value among the most negative one of each edge
	// Node Z = currentGraph.Z;
	// int maxOfMin = Integer.MIN_VALUE;
	// for (final Node obsNode : obsNodes) {
	// Edge eObsZ = currentGraph.findEdge(obsNode, Z);// initial check of process guarantees that eObsZ always exists.
	// // Determine the max negative value
	// Integer minValue = eObsZ.getMinValue();
	//
	// if (minValue != null) {
	// if (maxOfMin < minValue) maxOfMin = minValue;
	// }
	// }
	// LOG.finest("The less negative values found among all most negative ones present in edges Obs-->Z is " + maxOfMin);
	// if (maxOfMin < 0) {
	// boolean applied = false;
	// Node nextZ = nextGraph.Z;
	// // Add maxOfMin to each edge as unlabeled value
	// for (final Node obsNode : nextGraph.getObservables().values()) {
	// Edge eObsZ = nextGraph.findEdge(obsNode, nextZ);// initial check of process guarantees that eObsZ always exists.
	// // Determine the max negative value
	// String logMessage = "R6 adds a labeled value to edge " + eObsZ
	// + "\nresult: "
	// + Z.getName() + " <---(" + obsNode.getLabel() + ", " + maxOfMin + ")--- " + obsNode.getName();
	// if (eObsZ.mergeLabeledValue(obsNode.getLabel(), maxOfMin)) {
	// CSTNU.LOG.finer(logMessage);
	// R6calls++;
	// applied = true;
	// }
	// }
	// return applied;
	// }
	// return false;
	// }

	/**
	 * Applies the Negative QStar Rules, also known as R6. This is the new verion.<br>
	 * In this method all values are negative!
	 * 
	 * Given a labeled value (l, -w) in a edge Z<---P?, it checks whether in each edge Z<---O? where O? is the observation point relating a proposition forming
	 * the label 'l'
	 * there is one or more labeled values containing 'p'.<br>
	 * If yes (in all edges!), then the rule adds to each Z<---O edge,
	 * the labeled value (l', min), where min is the less negative value among the checked labeled values and l' is the label formed making the conjunction of
	 * all the checked label
	 * removing all opposite literals and literal associated to the considered observation nodes.<br>
	 * If no, returns.
	 * 
	 * @param currentGraph the originating graph.
	 * @param nextGraph the graph where to write the new constraints.
	 * @return true if one rule has been applied one time at least.
	 */
	static boolean negativeQStarR6(Graph currentGraph, Graph nextGraph) {
		CSTNU.LOG.finer("Label Modification R6: start.");
		if (currentGraph == null || nextGraph == null) {
			CSTNU.LOG.info("One parameter is null. Game over");
			return false;
		}
		final Map<Literal, Node> obsMap = currentGraph.getObservables();
		if (obsMap == null) return false;
		final Collection<Node> obsNodes = obsMap.values();

		// Check all obsNode-->Z edges
		Node Z = currentGraph.Z;
		for (final Node obsNode : obsNodes) {
			Edge eObsZ = currentGraph.findEdge(obsNode, Z);// initial check of process guarantees that eObsZ always exists.
			Literal l = obsNode.getObservable();

			for (final Entry<Label, Integer> entryObsZ : eObsZ.labeledValueSet()) {
				Label label = entryObsZ.getKey();
				if (label.isEmpty()) continue;
				Integer w = entryObsZ.getValue();
				Integer lessNegative = w;
				Boolean edgeSolvingLabelFound = false;
				HashSet<Literal> literalRemoved = new HashSet<>();
				literalRemoved.add(l);
				literalRemoved.add(l.negation());
				Label newLabel = new Label();
				TreeSet<Edge> edgesToUpdate = new TreeSet<>();

				for (Literal l1 : label.getAllStraight()) {
					Node othObs = currentGraph.getObservable(l1);
					if (othObs == null) {
						throw new RuntimeException("Graph does not containt a necessary observation node! That is impossible!");
					}

					Edge eOthObsZ = currentGraph.findEdge(othObs, Z);
					if (eOthObsZ == null) {
						throw new RuntimeException("Graph does not containt a necessary edge to Z! That is impossible!");
					}

					// scan all labeled values of the edge Z<---OthObs
					Label l2 = new Label();
					boolean found = false;
					for (final Entry<Label, Integer> entryOthObsZ : eOthObsZ.labeledValueSet()) {
						Label label1 = entryOthObsZ.getKey();
						if (label1.isEmpty()) continue;
						Integer w1 = entryOthObsZ.getValue();
						if (label1.contains(l) || label1.contains(l.negation())) {
							if (lessNegative < w1) lessNegative = w1;
							found = true;
							for (Literal ll : label1.getAll()) {
								if (l2.isConsistentWith(ll))
									l2.conjunct(ll);
								else {
									l2.remove(ll.negation());
									literalRemoved.add(ll);
									literalRemoved.add(ll.negation());
								}
							}
						}
					}
					if (found) {
						literalRemoved.add(l1);
						literalRemoved.add(l1.negation());
						newLabel.remove(l1);
						newLabel.remove(l1.negation());
						for (Literal ll : literalRemoved) {
							l2.remove(ll);
						}
						for (Literal ll : l2.getAll()) {
							if (newLabel.isConsistentWith(ll)) {
								newLabel.conjunct(ll);
							} else {
								literalRemoved.add(ll);
								literalRemoved.add(ll.negation());
								newLabel.remove(ll.negation());
							}
						}
						edgesToUpdate.add(nextGraph.getEdge(eOthObsZ.getName()));
					} else {
						edgeSolvingLabelFound = true;
					}
				}

				if (edgeSolvingLabelFound) continue;
				edgesToUpdate.add(nextGraph.getEdge(eObsZ.getName()));
				// We can add the minimal value to all edges in edgesToUpdate
				for (Edge e : edgesToUpdate) {
					LOG.finer("R6 is adding to " + e + " the following value: (" + newLabel + ", " + lessNegative + ")...");
					if (e.mergeLabeledValue(newLabel, lessNegative))
						LOG.finer("done!");
					else
						LOG.finer("NOT DONE because already done in the past");
				}
				R6calls++;
			}
		}
		CSTNU.LOG.finer("Label Modification R6: end.");
		return false;
	}

	/**
	 * Applies the rules R1 and R3 and R5 about the simplification of constraint having label decided in the future.<br>
	 * For about the rules, see javadoc of method {@link #labelModificationR1Action(Node, Node, Node, Edge, Edge, Literal, Edge, Graph, boolean))} and
	 * {@link #labelModificationR3R5Action(Node, Node, Node, Edge, Edge, Literal, Edge, Graph, boolean))}
	 * 
	 * @param currentGraph the originating graph.
	 * @param nextGraph the graph where to write the new constraints.
	 * @param instantaneousReaction
	 * @return true if one rule has been applied one time at least.
	 * @see CSTNU#labelModificationR1Action(Node, Node, Node, Edge, Edge, Literal, Edge, Graph, boolean))
	 *      CSTNU#labelModificationR3Action(Node, Node, Node, Edge, Edge, Literal, Edge)
	 */
	@SuppressWarnings("javadoc")
	static boolean labelModificationR1R3R5(Graph currentGraph, Graph nextGraph, boolean instantaneousReaction) {
		if ((currentGraph == null)) {
			CSTNU.LOG.info("One parameter is null. Game over");
			return false;
		}

		boolean ruleApplied = false;
		final Map<Literal, Node> obsMap = currentGraph.getObservables();
		if (obsMap == null) return false;
		final Collection<Node> obsNodes = obsMap.values();

		CSTNU.LOG.finer("Label Modification R1 and R3 and R5: start.");
		for (final Node obsNode : obsNodes) {
			final Literal p = obsNode.getObservable();
			if (p == null)
				throw new IllegalArgumentException("The observation node " + obsNode + " has no specification of observed proposition!");
			for (final Edge eObsX : currentGraph.getOutEdges(obsNode)) { // node X
				final Node nX = currentGraph.getDest(eObsX);
				if ((eObsX.getMinValue() == null) || (eObsX.getMinValue() > 0)) continue;// reduction rule

				// R1 rules
				for (final Edge eXY : currentGraph.getOutEdges(nX)) {
					final Node nY = currentGraph.getDest(eXY);
					final Edge eXYnew = nextGraph.findEdge(nextGraph.getNode(nX.getName()), nextGraph.getNode(nY.getName()));
					ruleApplied = (CSTNU.labelModificationR1Action(obsNode, nX, nY, eXY, eObsX, p, eXYnew, currentGraph, instantaneousReaction)) ? true
							: ruleApplied;
				}

				// R3 R5 Rules
				for (final Edge eYX : currentGraph.getInEdges(nX)) {
					final Node nY = currentGraph.getSource(eYX);
					if (nY.equalsByName(obsNode)) continue;
					final Edge eYXnew = nextGraph.findEdge(nextGraph.getNode(nY.getName()), nextGraph.getNode(nX.getName()));
					ruleApplied = (CSTNU.labelModificationR3R5Action(obsNode, nX, nY, eYX, eObsX, p, eYXnew, currentGraph, instantaneousReaction)) ? true
							: ruleApplied;
				}
			}
		}
		CSTNU.LOG.finer("Label Modification R1R3R5: end.");
		return ruleApplied;
	}

	/**
	 * Rule R1 remove propositions from labels of edge X-->Y that cannot be evaluated when the edge has to be
	 * considered.
	 * 
	 * <pre>
	 * if P? --[ab, ◇, w]--&gt; X --[bgp,U,v]--&gt; Y  and w&le;0 and v&lt;w, 
	 * then the constraint between X and Y is modified as X --[abg,U,v]--[bgp,U,v]--> Y,
	 * where U can be ◇ or an upper letter.
	 * </pre>
	 * 
	 * @param obs observation node
	 * @param nX x node
	 * @param nY y node
	 * @param eXY Edge containing the constrain to modify
	 * @param eObsX Edge connecting observation node and x.
	 * @param p the Observation proposition (it is redundant... only to speed up the method)
	 * @param eXYnew Edge that will contain the new determined labels.
	 * @param g graph where to search observation nodes.
	 * @param instantaneousReaction
	 * @return true if a rule has been applied.
	 */
	static boolean labelModificationR1Action(Node obs, Node nX, Node nY, Edge eXY, Edge eObsX, Literal p, Edge eXYnew, Graph g, boolean instantaneousReaction) {
		if (eXY == null) return false;

		boolean ruleApplied = false;

		final Set<Entry<Label, Integer>> obs_xLabeledValueSet = new HashSet<>(eObsX.labeledValueSet());

//		CSTNU.LOG.finer("Label Modification R1: start.");
		LOG.finest("obs_xLabeledValueSet: " + obs_xLabeledValueSet.toString());
		// Merge all possible labeled values and Upper Case labeled values of edges between Y and X in a single set.
		final Set<Entry<Entry<Label, String>, Integer>> x_yLabeledValueSet = eXY.getAllUpperCaseAndOrdinaryLabeledValuesSet();

		for (final Entry<Label, Integer> entryObs : obs_xLabeledValueSet) {
			final Integer w = entryObs.getValue();
			final Label l = entryObs.getKey();

			if ((w > 0) || (l.contains(p) || l.contains(p.negation()))) continue; // R1 works with negative w associated to a label without 'p'.

			for (final Entry<Entry<Label, String>, Integer> entryXY : x_yLabeledValueSet) {
				final Integer v = entryXY.getValue();
				// condition on v value and its relation with w.
				// w is surely <=0; v can be any value. R1 has to applied when v<=-w (in case of instantaneous, v<-w). So, if v<=-w, then R1 is applied.
				if (v > -w || (instantaneousReaction && v == -w)) continue; // R1 cannot be applied

				final Label l1 = new Label(entryXY.getKey().getKey());
				if (!l1.contains(p) && !l1.contains(p.negation())) continue;
				if (!l.isConsistentWith(l1)) continue;

				final String UCLabelXY = entryXY.getKey().getValue();
				boolean r1Applied = false;

				final Label l1WithoutP = new Label(l1);
				l1WithoutP.remove(p);
				l1WithoutP.remove(p.negation());
				final Label[] alphaBetaGammaPart = CSTNU.getAlphaBetaGamma(l, l1WithoutP);
				final Label alpha = alphaBetaGammaPart[0];
				final Label beta = alphaBetaGammaPart[1];
				final Label gamma1 = getGammaCleaned(alphaBetaGammaPart[2], p, g);
				Label abg1 = alpha.conjunction(beta).conjunction(gamma1);

				if (abg1 == null) {
					final String msg = "The label alpha beta gamma is null and it cannot be null: \n"
							+ "alpha: " + alpha + "; beta: " + beta + "; gamma': " + gamma1;
					CSTNU.LOG.severe(msg);
					throw new IllegalArgumentException(msg);
				}
				if (!checkNodeLabelsSubsumption(nX, nY, abg1, eXY.getName(), "R1")) {
					// I check if the label subsumes the label of the endpoints before to proceed.
					// It should not necessary, but I put here as a guard!
					CSTNU.LOG.finer("Detail about the error of application R1 to edge " + eXY
							+ ":\npartic: "
							+ obs.getName() + " ---(" + l + ", " + Constants.EMPTY_UPPER_CASE_LABEL_STRING + ", " + w + ")---> " + nX.getName()
							+ " ---(" + l1 + ", " + UCLabelXY + ", " + v + ")---> " + nY.getName()
							+ "\nresult: " + nX.getName() + " ---(" + abg1 + ", " + UCLabelXY + ", " + v + ")---> " + nY.getName());
					throw new IllegalStateException("Rule R1 cannot determine label that does not subsume node labels!");
				}

				if (UCLabelXY.equals(Constants.EMPTY_UPPER_CASE_LABEL_STRING)) {
					eXYnew.putLabeledValueToRemovedList(l1, v);
//FIXME: new version					eXYnew.removeLabel(l1);
					// CSTNU.LOG.finest("Edge " + eXY.getName() + " after remove " + l1 + " in R1 application: " + eXYnew.toString());
					r1Applied = eXYnew.mergeLabeledValue(abg1, v);
				} else {
//FIXME: new version					eXYnew.removeUpperLabel(l1, UCLabelXY);
					eXYnew.putUpperLabeledValueToRemovedList(l1, UCLabelXY, v);
					r1Applied = eXYnew.mergeUpperLabelValue(abg1, UCLabelXY, v);
				}
				if (r1Applied) {
					CSTNU.LOG.finer("R1 adds a label to edge " + eXY
							+ ":\npartic: "
							+ obs.getName() + " ---(" + l + ", " + Constants.EMPTY_UPPER_CASE_LABEL_STRING + ", " + w + ")---> " + nX.getName()
							+ " ---(" + l1 + ", " + UCLabelXY + ", " + v + ")---> " + nY.getName()
							+ "\nresult: " + nX.getName() + " ---(" + abg1 + ", " + UCLabelXY + ", " + v + ")---> " + nY.getName());
					ruleApplied = true;
					R1calls++;
				}
				// CSTNU.LOG.finer("Edge " + eXYnew.getName() + " after the R1 application to no case label: " + eXYnew.toString());
//FIXME: new version				if (alpha.size() == 0) continue;
//				final Set<Label> notAlphaSet = getNotAlpha(alpha, g);
//				for (final Label notAlpha : notAlphaSet) {
//					abg1 = l1.conjunction(notAlpha);
//					r1Applied = false;
//					if (!checkNodeLabelsSubsumption(nX, nY, abg1, eXY.getName(), "R1")) {
//						// I check if the label subsumes the label of the endpoints before to proceed.
//						// It should not necessary, but I put here as a guard!
//						CSTNU.LOG.finer("Detail about the error of application R1 to edge " + eXY
//								+ ":\npartic: "
//								+ obs.getName() + " ---(" + l + ", " + Constants.EMPTY_UPPER_CASE_LABEL_STRING + ", " + w + ")---> " + nX.getName()
//								+ " ---(" + l1 + ", " + UCLabelXY + ", " + v + ")---> " + nY.getName()
//								+ "\nresult: " + nX.getName() + " ---(" + abg1 + ", " + UCLabelXY + ", " + v + ")---> " + nY.getName());
//						throw new IllegalStateException("Rule R1 cannot determine label that does not subsume node labels!");
//					}
//					if (UCLabelXY.equals(Constants.EMPTY_UPPER_CASE_LABEL_STRING)) {
//						r1Applied = eXYnew.mergeLabeledValue(abg1, v);
//					} else {
//						r1Applied = eXYnew.mergeUpperLabelValue(abg1, UCLabelXY, v);
//					}
//					if (r1Applied) {
//						CSTNU.LOG.finer("R1 applied to edge " + eXY
//								+ ":\npartic: "
//								+ obs.getName() + " ---(" + l + ", " + Constants.EMPTY_UPPER_CASE_LABEL_STRING + ", " + w + ")---> " + nX.getName()
//								+ " ---(" + l1 + ", " + UCLabelXY + ", " + v + ")---> " + nY.getName()
//								+ "\nresult: " + nX.getName() + " ---(" + abg1 + ", " + UCLabelXY + ", " + v + ")---> " + nY.getName());
//						R1calls++;
//						ruleApplied = true;
//					}
//				}
			}
		}
		if (ruleApplied)
			CSTNU.LOG.finer("Edge " + eXYnew.getName() + " after R1 application: " + eXYnew.toString());
//		CSTNU.LOG.finer("Label Modification R1: end.");
		return ruleApplied;
	}

	/**
	 * Rule R3 requires to be considered in more cases than R1.
	 * 
	 * <pre>
	 * if P? --[ab, U ,w]--&gt; X &lt;--[bgp, U1, v]-- Y  and (w &le;0 and v&ge;w) 
	 * then the constraint between Y and X is modified as
	 * X &lt;--[abg, U1, v]--[bgp, U1, v]-- Y,
	 * when U is empty or is equal to U1.
	 * </pre>
	 * 
	 * Rule R5 requires preliminary conditions similar to the R3 ones.
	 * 
	 * <pre>
	 * if P? --[ab, U ,w]--&gt; X &lt;--[bgp, U1, v]-- Y  and (w &leq; 0 and v&lt;w), 
	 * then the constraint between Y and X is modified as 
	 * X &lt;--[abg, U1, w]--[bgp, U1, v]-- Y,
	 * when U is empty or is equal to U1.
	 * </pre>
	 * 
	 * @param nObs observation node
	 * @param nX x node
	 * @param nY y node
	 * @param eYX Edge containing the constrain to modify
	 * @param eObsX Edge connecting observation node and x.
	 * @param p the Observation proposition (it is redundant... only to speed up the method)
	 * @param eYXnew Edge that will contain the new determined labels.
	 * @param g graph where to search observation points.
	 * @param instantaneousReaction
	 * @return true if a rule has been applied.
	 */
	static boolean labelModificationR3R5Action(Node nObs, Node nX, Node nY, Edge eYX, Edge eObsX, Literal p, Edge eYXnew, Graph g, boolean instantaneousReaction) {
		if (eYX == null) return false;

		boolean ruleApplied = false;

		// Merge all possible labeled values and Upper Case labeled values of edges between Obs and X in a single set.
		final Set<Entry<Entry<Label, String>, Integer>> obs_xLabeledValueSet = eObsX.getAllUpperCaseAndOrdinaryLabeledValuesSet();

		// Merge all possible labeled values and Upper Case labeled values of edges between Y and X in a single set.
		final Set<Entry<Entry<Label, String>, Integer>> y_xLabeledValueSet = eYX.getAllUpperCaseAndOrdinaryLabeledValuesSet();

		// CSTNU.LOG.finest("Label Modification R3: start.");

		for (final Entry<Entry<Label, String>, Integer> entryObsX : obs_xLabeledValueSet) {
			final Integer w = entryObsX.getValue();
			if (w > 0) continue; // R3 and R5 work with negative w.

			final Label l = entryObsX.getKey().getKey();
			if (l.contains(p) || l.contains(p.negation())) continue; // R3 and R5 work with a w associated to a label without 'p'.

			final String UCLabelObsX = entryObsX.getKey().getValue();

			for (final Entry<Entry<Label, String>, Integer> entryYX : y_xLabeledValueSet) {
				final Integer v = entryYX.getValue();

				final Label l1 = new Label(entryYX.getKey().getKey());
				if (!l1.contains(p) && !l1.contains(p.negation())) continue;
				if (!l.isConsistentWith(l1)) continue;

				final String UCLabelYX = entryYX.getKey().getValue();
				if (!UCLabelObsX.equals(Constants.EMPTY_UPPER_CASE_LABEL_STRING) && !UCLabelObsX.equals(UCLabelYX)) continue;

				final Label l1WithoutP = new Label(l1);
				l1WithoutP.remove(p);
				l1WithoutP.remove(p.negation());
				final Label[] alphaBetaGammaPart = CSTNU.getAlphaBetaGamma(l, l1WithoutP);
				final Label alpha = alphaBetaGammaPart[0];
				final Label beta = alphaBetaGammaPart[1];
				final Label gamma1 = getGammaCleaned(alphaBetaGammaPart[2], p, g);
				LOG.finest("Rule R3 details alpha=" + alpha);
				LOG.finest("Rule R3 details beta=" + beta);
				LOG.finest("Rule R3 details gamma1=" + gamma1);
				Label abg1 = alpha.conjunction(beta).conjunction(gamma1);

				if (abg1 == null) {
					final String msg = "The label alpha beta gamma is null and it cannot be null: \n"
							+ "alpha: " + alpha + "; beta: " + beta + "; gamma: " + gamma1;
					CSTNU.LOG.severe(msg);
					throw new IllegalArgumentException(msg);
				}

				// I check if the label subsumes the label of the endpoints before to proceed
				if (!checkNodeLabelsSubsumption(nY, nX, abg1, eYX.getName(), "R3R5")) {
					CSTNU.LOG.finer("Details because R3R5 cannot be applied to edge " + eYX + ":\n"
							+ nObs.getName() + " ---(" + l + ", " + UCLabelObsX + ", " + w + ")---> " + nX.getName()
							+ " <---(" + l1 + ", " + UCLabelYX + ", " + v + ")--- " + nY.getName());
					continue;
				}

				boolean r3Applied = false, r5Applied = false;
				// R3 RULE
				// v >= w (in case of instantaneous activations, the case v=w has been already sort out not allowing to reach this line.).
				if (v >= w) {
					// R3 rule
					if (UCLabelYX.equals(Constants.EMPTY_UPPER_CASE_LABEL_STRING)) {
						eYXnew.putLabeledValueToRemovedList(l1, v);
//FIXME: new version						eYXnew.removeLabel(l1);
						r3Applied = eYXnew.mergeLabeledValue(abg1, v);
					} else {
//FIXME: new version						eYXnew.removeUpperLabel(l1, UCLabelYX);
						eYXnew.putUpperLabeledValueToRemovedList(l1, UCLabelYX, v);
						r3Applied = eYXnew.mergeUpperLabelValue(abg1, UCLabelYX, v);
					}
					if (r3Applied) {
						// R3 changed the edge
						CSTNU.LOG.finer("R3 adds a label to edge " + eYX + ":\n"
								+ "partic: " + nObs.getName() + " ---(" + l + ", " + UCLabelObsX + ", " + w + ")---> " + nX.getName()
								+ " <---(" + l1 + ", " + UCLabelYX + ", " + v + ")--- " + nY.getName()
								+ "\nresult: " + nX.getName() + " <---(" + abg1 + ", " + UCLabelYX + ", " + v + ")--- " + nY.getName());
						R3calls++;
						ruleApplied = true;
					}
//FIXME: new version					if (alpha.size() == 0) continue; // || v < w) continue;// v <w for R5 that has no a part with negative alpha
//					final Set<Label> notAlphaSet = getNotAlpha(alpha, g);
//					r3Applied = false;
//					for (final Label notAlpha : notAlphaSet) {
//						abg1 = l1.conjunction(notAlpha);
//						// I check if the label subsumes the label of the endpoints before to proceed
//						if (!checkNodeLabelsSubsumption(nY, nX, abg1, eYX.getName(), "R3")) continue;
//						if (UCLabelYX.equals(Constants.EMPTY_UPPER_CASE_LABEL_STRING))
//							r3Applied = eYXnew.mergeLabeledValue(abg1, v);
//						else
//							r3Applied = eYXnew.mergeUpperLabelValue(abg1, UCLabelYX, v);
//						if (r3Applied) {
//							// R3 changed the edge
//							R3calls++;
//							CSTNU.LOG.finer("R3 applied to edge considering not alpha:\n"
//									+ "partic: " + nObs.getName() + " ---(" + l + ", " + UCLabelObsX + ", " + w + ")---> " + nX.getName()
//									+ " <---(" + l1 + ", " + UCLabelYX + ", " + v + ")--- " + nY.getName()
//									+ "\nresult: " + nX.getName() + " <---(" + abg1 + ", " + UCLabelYX + ", " + v + ")--- " + nY.getName());
//							ruleApplied = true;
//						}
//					}
				} else {
					// R5 rule
					// It requires both w and v negative and v<w.
					if (UCLabelYX.equals(Constants.EMPTY_UPPER_CASE_LABEL_STRING)) {
						r5Applied = eYXnew.mergeLabeledValue(abg1, w);
					} else {
						r5Applied = eYXnew.mergeUpperLabelValue(abg1, UCLabelYX, w);
					}
					if (r5Applied) {
						// R5 changed the edge
						R5calls++;
						CSTNU.LOG.finer("R5 adds a label to edge " + eYX + ":\n"
								+ "partic: " + nObs.getName() + " ---(" + l + ", " + UCLabelObsX + ", " + w + ")---> " + nX.getName()
								+ " <---(" + l1 + ", " + UCLabelYX + ", " + v + ")--- " + nY.getName()
								+ "\nresult: " + nX.getName() + " <---(" + l1 + ", " + UCLabelYX + ", " + v + ")(" + abg1 + ", " + UCLabelYX + ", " + w
								+ ")--- "
								+ nY.getName());
						ruleApplied = true;
					}
				}
			}
		}
		if (ruleApplied)
			CSTNU.LOG.finer("Edge " + eYXnew.getName() + " after R3R5 application: " + eYXnew.toString());
		CSTNU.LOG.finest("Label Modification R3R5: end.");
		return ruleApplied;
	}

	/**
	 * Apply Morris lower case reduction (see page 1196 of the article).
	 * 
	 * <pre>
	 *     l1, x     l2, c:y                    l1l2, x+y
	 * A  <-------C <--------D and x<=0 adds A <-----------D
	 * </pre>
	 * 
	 * @param currentGraph the originating graph.
	 * @param nextGraph the graph where to write the new constraints.
	 * @return true if a reduction is applied at least
	 */
	static boolean lowerCaseRule(Graph currentGraph, Graph nextGraph) {
		if ((currentGraph == null) || (nextGraph == null)) {
			CSTNU.LOG.info("One parameter is null. Game over");
			return false;
		}
		final Set<Edge> lowerCaseEdge = currentGraph.getLowerLabeledEdges();
		/*
		 * I use the same node/edge ids of the Morris paper: A, C, D for nodes, and CA, DC, and DA for edges.
		 */
		Node A, C, D;
		Edge DA;
		boolean reductionApplied = false;
		Set<Entry<Entry<Label, String>, Integer>> DCMap;
		CSTNU.LOG.finer("Lower Case Rule: start.");
		for (final Edge DC : lowerCaseEdge) {
			DCMap = DC.getLowerLabelSet();
			if (DCMap.size() == 0) continue;
			D = currentGraph.getSource(DC);
			C = currentGraph.getDest(DC);

			for (final Edge CA : currentGraph.getOutEdges(C)) {
				A = currentGraph.getDest(CA);
				if (A.equalsByName(D) || A.equalsByName(C)) continue;// A==D is a loop =0; A==C, if x<0, then there is a
																		// negative loop
				if ((CA.getMinValue() == null) || (CA.getMinValue() > 0)) continue; // rule condition!

				final Set<Entry<Label, Integer>> CAMap = CA.labeledValueSet();

				DA = nextGraph.findEdge(nextGraph.getNode(D.getName()), nextGraph.getNode(A.getName()));

				for (final Entry<Entry<Label, String>, Integer> entryDC : DCMap) {
					final Label l2 = entryDC.getKey().getKey();
					// Node contNode = entryContingent.getKey().getValue();
					final Integer y = entryDC.getValue();
					// redundant check
					// if (!contNode.equalsByName(C)) {
					// throw new IllegalStateException(
					// "Found a lower case label that has destination different from the label: " + DC);
					// }
					for (final Entry<Label, Integer> entryCA : CAMap) {
						final Integer x = entryCA.getValue();
						if (x > 0) continue;
						final Label l1 = entryCA.getKey();
						final Label l1l2 = l1.conjunction(l2);
						if (l1l2 == null) continue;
						// I check if the label subsumes the label of the endpoints before to proceed
						// if (!checkNodeLabelsSubsumption(D, A, l1l2, (DA == null) ? "e" + D.getName() + A.getName() : DA.getName(), "Lower Case Rule"))
						// continue;// THERE IS A MORE GENERAL CHECK

						if (DA == null) {
							DA = new Edge("e" + D.getName() + A.getName(), Edge.Type.derived);
							nextGraph.addEdge(DA, nextGraph.getNode(D.getName()), nextGraph.getNode(A.getName()));
							LOG.finer("lowerCaseRule: added edge " + DA.getName());
						}
						final Integer oldZ = DA.getValue(l1l2);
						final Integer z = y + x;
						final String oldDA = DA.toString();

						if (DA.mergeLabeledValue(l1l2, z)) {
							reductionApplied = true;
							CSTNU.LOG.finer("Lower Case applied to edge " + oldDA + ":\n"
									+ "partic: " + A.getName() + " <---(" + l1 + ", " + Constants.EMPTY_UPPER_CASE_LABEL_STRING + ", " + x + ")--- "
									+ C.getName() + " <---(" + l2 + ", " + entryDC.getKey().getValue().toLowerCase() + ", " + y + ")--- " + D.getName()
									+ "\nresult: " + A.getName() + " <---(" + l1l2 + ", " + Constants.EMPTY_UPPER_CASE_LABEL_STRING + ", " + z + ")--- "
									+ D.getName() + "; old value: " + oldZ);
							if (!z.equals(oldZ)) CSTNU.LOG.finer("Edge " + DA.getName() + " after the rule: " + DA.toString());
						}
					}
				}
			}
		}
		CSTNU.LOG.finer("Lower Case Rule: end.");
		return reductionApplied;
	}

	/**
	 * @param args
	 */
	@SuppressWarnings("unused")
	public static void main(String[] args) {

		Edge dc, ca;
		Node C;
		Graph g, g1;

		// System.out.printf("UPPER CASE\n");
		// g = new Graph();
		// dc = new Edge("DC");
		// ca = new Edge("CA");
		// ca.mergeUpperLabelValue(Label.parse("AB"), "B", 3);
		// dc.mergeLabeledValue(Label.parse("B"), -13);
		// dc.mergeLabeledValue(Label.parse("C"), 11);
		// C = new Node("C");
		// g.addEdge(dc, new Node("D"), C);
		// g.addEdge(ca, C, new Node("A"));
		// g1 = new Graph(g);
		//
		// System.out.printf("G: %s\n", g);
		// System.out.printf("G1.hasSameEdge(G): %s\n", g1.hasAllEdgesOf(g));
		// CSTNU.upperCaseRule(g, g1);
		// System.out.printf("G.hasSameEdge(G1): %s\n", g.hasAllEdgesOf(g1));
		// System.out.printf("G: %s\n", g1);

		// System.out.printf("LOWER CASE\n");
		// g = new Graph();
		// dc = new Edge("DC");
		// ca = new Edge("CA");
		// dc.mergeLowerLabelValue(Label.parse("AB"), "c", 3);
		// ca.mergeLabeledValue(Label.parse("B"), -13);
		// ca.mergeLabeledValue(Label.parse("C"), -11);
		// C = new Node("C");
		// g.addEdge(dc, new Node("D"), C);
		// g.addEdge(ca, C, new Node("A"));
		// g1 = new Graph(g);
		//
		// System.out.printf("G: %s\n", g);
		// System.out.printf("G1.hasSameEdge(G): %s\n", g1.hasAllEdgesOf(g));
		// CSTNU.lowerCaseRule(g, g1);
		// System.out.printf("G.hasSameEdge(G1): %s\n", g.hasAllEdgesOf(g1));
		// System.out.printf("G: %s\n", g1);
		//
		//
		// System.out.printf("CROSS CASE\n");
		// g = new Graph();
		// dc = new Edge("DC");
		// ca = new Edge("CA");
		// dc.mergeLowerLabelValue(Label.parse("AB"), "c", 3);
		// ca.mergeUpperLabelValue(Label.parse("B¬C"), "D", -3);
		// C = new Node("C");
		// g.addEdge(dc, new Node("D"), C);
		// g.addEdge(ca, C, new Node("A"));
		// g1 = new Graph(g);
		//
		// // System.out.printf("G: %s\n", g);
		// // System.out.printf("G1.hasSameEdge(G): %s\n", g1.hasAllEdgesOf(g));
		// CSTNU.crossCaseRule(g, g1);
		// // System.out.printf("G.hasSameEdge(G1): %s\n", g.hasAllEdgesOf(g1));
		// System.out.printf("G: %s\n", g1);

		// System.out.printf("LABEL REMOVAL CASE\n");
		// g = new Graph();
		// final Edge ab = new Edge("AB");
		// ca = new Edge("CA");
		// ca.mergeUpperLabelValue(Label.parse("AB"), "B", 3);
		// ca.mergeUpperLabelValue(Label.parse("¬B"), "B", 4);
		// ab.mergeLowerLabelValue(Label.parse("B"), "b", 13);
		// final Node A = new Node("A");
		// g.addEdge(ab, A, new Node("B"));
		// g.addEdge(ca, new Node("C"), A);
		// g1 = new Graph(g);
		//
		// // System.out.printf("G: %s\n", g);
		// // System.out.printf("G1.hasSameEdge(G): %s\n", g1.hasAllEdgesOf(g));
		// CSTNU.caseLabelRemovalRule(g, g1);
		// // System.out.printf("G.hasSameEdge(G1): %s\n", g.hasAllEdgesOf(g1));
		// // System.out.printf("G: %s\n", g1);
		//

		// System.out.printf("R1-R3 CASE\n");
		// g = new Graph();
		// Node P = new Node("P", new Literal('p'));
		// Node X = new Node("X");
		// Node Y = new Node("Y");
		// Edge px = new Edge("PX");
		// px.mergeLabeledValue(Label.parse("AB"), -10);
		// px.mergeUpperLabelValue(Label.parse("AB"), "C", -11);
		// Edge yx = new Edge("YX");
		// yx.mergeLabeledValue(Label.parse("BGp"), -4);
		// yx.mergeUpperLabelValue(Label.parse("BGp"), "C", -7);
		// yx.mergeUpperLabelValue(Label.parse("BG¬p"), "C", -4);
		//
		// Edge xy = new Edge("XY");
		// xy.mergeLabeledValue(Label.parse("BGp"), 5);
		// xy.mergeUpperLabelValue(Label.parse("BGp"), "C", 8);
		// xy.mergeUpperLabelValue(Label.parse("BG¬p"), "C", 9);
		//
		// g.addEdge(px, P, X);
		// g.addEdge(yx, Y, X);
		// g.addEdge(xy, X, Y);
		// g1 = new Graph(g);
		//
		// System.out.printf("G: %s\n", g);
		// // System.out.printf("G1.hasSameEdge(G): %s\n", g1.hasAllEdgesOf(g));
		// CSTNU.labelModificationR1R2R3(g);
		// // System.out.printf("G.hasSameEdge(G1): %s\n", g.hasAllEdgesOf(g1));
		// System.out.printf("G: %s\n", g);
	}

	/**
	 * Build the distance graph from g considering all standard constraints and adding all upper label constraints as
	 * standard constraints.
	 * 
	 * @param g a CSTNU instance
	 * @return the all max projection of the graph g.
	 */
	static Graph makeAllMaxProjection(Graph g) {
		if (g == null) return null;
		final Graph distance = new Graph(g);

		for (final Edge e : distance.getUpperLabeledEdges())
			for (final Entry<Entry<Label, String>, Integer> entry : e.getUpperLabelSet())
				e.mergeLabeledValue(entry.getKey().getKey(), entry.getValue());
		return distance;
	}

	/**
	 * Determines the minimal distance between all pair of vertexes modifying the given graph if there is no negative
	 * cycle.<br>
	 * This method uses the {@link LabeledValueMap#summedTo(LabeledValueMap)} in order to determine the right labels for
	 * the edge.
	 * 
	 * @param g the graph
	 * @return true if the matrix represents the minimal distance between all pairs of nodes, false if there is a
	 *         negative cycle at least. If the response is false, the matrix does not represent a distance graph!
	 */
	static public boolean minimalDistanceGraph(Graph g) {
		final int n = g.getVertexCount();
		final Node[] node = g.getVerticesArray();
		Node iV, jV, kV;
		Edge ik, kj, ij;
		LabeledValueMap<Integer> newLabelSet;

		for (int k = 0; k < n; k++) {
			kV = node[k];
			for (int i = 0; i < n; i++) {
				iV = node[i];
				for (int j = 0; j < n; j++) {
					if ((k == i) && (i == j)) continue;
					jV = node[j];
					ik = g.findEdge(iV, kV);
					kj = g.findEdge(kV, jV);
					if ((ik == null) || (kj == null)) continue;

					newLabelSet = ik.getLabeledValueMap().summedTo(kj.getLabeledValueMap());
					if (newLabelSet.size() > 0) {
						ij = g.findEdge(iV, jV);
						if (ij == null) {
							ij = new Edge("e" + node[i].getName() + node[j].getName(), Edge.Type.derived);
							g.addEdge(ij, iV, jV);
						}
						ij.mergeLabeledValue(newLabelSet);
						if (i == j) // check negative cycles
							if (newLabelSet.isThereNegativeValues()) return false;
					}
				}
			}
		}
		return true;
	}

	/**
	 * Determines the minimal distance between all pair of vertexes modifying the given graph if there is no negative
	 * cycle.
	 * 
	 * @param g the graph
	 * @return true if the matrix represents the minimal distance between all pairs of nodes, false if there is a
	 *         negative cycle at least. If the response is false, the matrix does not represent a distance graph!
	 */
	static public boolean minimalDistanceGraphFast(Graph g) {
		final int n = g.getVertexCount();
		final Node[] node = g.getVerticesArray();
		Node iV, jV, kV;
		Edge ik, kj, ij;
		Integer v;
		Label l;
		LabeledValueMap<Integer> ijMap = null;
		for (int k = 0; k < n; k++) {
			kV = node[k];
			for (int i = 0; i < n; i++) {
				iV = node[i];
				for (int j = 0; j < n; j++) {
					if ((k == i) && (i == j)) continue;
					jV = node[j];
					ik = g.findEdge(iV, kV);
					kj = g.findEdge(kV, jV);
					if ((ik == null) || (kj == null)) continue;
					ij = g.findEdge(iV, jV);

					final Set<Entry<Label, Integer>> ikMap = ik.labeledValueSet();
					final Set<Entry<Label, Integer>> kjMap = kj.labeledValueSet();
					if ((k == i) || (k == j))//
						ijMap = new LabeledValueMap<>(ij.getLabeledValueMap());// this is necessary to avoid concurrent access to the same map by the iterator.
					else
						ijMap = null;

					for (final Entry<Label, Integer> ikL : ikMap)
						for (final Entry<Label, Integer> kjL : kjMap) {
							l = ikL.getKey().conjunction(kjL.getKey());
							if (l == null) continue;
							if (ij == null) {
								ij = new Edge("e" + node[i].getName() + node[j].getName(), Edge.Type.derived);
								g.addEdge(ij, iV, jV);
							}
							v = ikL.getValue() + kjL.getValue();
							if (ijMap != null)
								ijMap.mergeLabeledValue(l, v);
							else
								ij.mergeLabeledValue(l, v);
							if (i == j) // check negative cycles
								if (v < 0) {
									LOG.finer("Found a negative cycle on node " + iV.getName() + ": "
											+ ((ijMap != null) ? ijMap : ij));
									return false;
								}
						}
					if (ijMap != null) ij.setLabeledValue(ijMap);
				}
			}
		}
		return true;
	}

	/**
	 * Apply Morris no case reduction to all constraints but the Upper or Lower Label ones.
	 * 
	 * <pre>
	 *     l1, x       l2, y                    l1l2, x+y
	 * A  <-------C <--------D and x<=0 adds A <----------D
	 * </pre>
	 * 
	 * @param currentGraph the originating graph.
	 * @param nextGraph the graph where to write the new constraints.
	 * @return true if a reduction is applied at least
	 */
	static boolean noCaseRule(Graph currentGraph, Graph nextGraph) {
		if ((currentGraph == null) || (nextGraph == null)) {
			CSTNU.LOG.info("One parameter is null. Game over");
			return false;
		}

		final int n = currentGraph.getVertexCount();
		final Node[] node = currentGraph.getVerticesArray();
		Node A, D, C, AinNextGraph, DinNextGraph;
		Edge CA, DC, DA;
		boolean ruleApplied = false;

		CSTNU.LOG.finer("No-Case Rule: start.");
		for (int k = 0; k < n; k++) {
			C = node[k];
			for (Iterator<Edge> eCAIter = currentGraph.getOutEdges(C).iterator(); eCAIter.hasNext();) {
				CA = eCAIter.next();
				A = currentGraph.getDest(CA);
				if (C == A) continue;// self loop are useless!
				for (Iterator<Edge> eDCIter = currentGraph.getInEdges(C).iterator(); eDCIter.hasNext();) {
					DC = eDCIter.next();
					D = currentGraph.getSource(DC);
					if (D == C || A == D) continue; // self loop are useless!

					// if ((CA == null) || (DC == null)) continue; // Luke || CA.isContingentEdge() || DC.isContingentEdge()) continue; // Luke rule condition!
					DA = nextGraph.findEdge((DinNextGraph = nextGraph.getNode(D.getName())), (AinNextGraph = nextGraph.getNode(A.getName())));
					// if ((DA != null) && DA.isContingentEdge()) continue; // Luke no contingent constraints.

					final Set<Entry<Label, Integer>> CAMap = CA.labeledValueSet();
					final Set<Entry<Label, Integer>> DCMap = DC.labeledValueSet();
					for (final Entry<Label, Integer> CAEntry : CAMap) {
						final Label l1 = CAEntry.getKey();
						final Integer x = CAEntry.getValue();
						for (final Entry<Label, Integer> DCEntry : DCMap) {
							final Label l2 = DCEntry.getKey();
							final Label l1l2 = l1.conjunction(l2);
							if (l1l2 == null) continue;
							final Integer y = DCEntry.getValue();

							if (DA == null) {
								DA = new Edge("e" + D.getName() + A.getName(), Edge.Type.derived);
								nextGraph.addEdge(DA, DinNextGraph, AinNextGraph);
								LOG.finer("No-CaseRule: added edge " + DA.getName());
							}
							final Integer oldZ = DA.getValue(l1l2);
							final Integer z = x + y;
							final String oldDA = DA.toString();
							if (DA.mergeLabeledValue(l1l2, z)) {
								ruleApplied = true;
								NoCaseLabelcalls++;
								CSTNU.LOG.finer("No-Case applied to edge " + oldDA + ":\n"
										+ "partic: "
										+ A.getName() + " <---(" + l1 + ", ◇, " + x + ")--- " + C.getName() + " <---(" + l2 + ", ◇, " + y + ")--- "
										+ D.getName()
										+ "\nresult: " + A.getName() + " <---(" + l1l2 + ", ◇, " + z + ")--- " + D.getName()
										+ "; old value: " + oldZ);
								if (!z.equals(oldZ)) CSTNU.LOG.finer("Edge " + DA.getName() + " after No-Case Rule: " + DA.toString());
							}
						}
					}
				}
			}
		}
		CSTNU.LOG.finer("No-Case Rule: end.");
		return ruleApplied;
	}

	/**
	 * Applies "Observation Case" rule.
	 * 
	 * <pre>
	 * Y &lt;---[αβp, ◇, u]--- X 
	 *   ---[βγ¬p, ◇, -v]--&gt;
	 *   and u&lt;v 
	 *   adds P? &lt;--[αβγ, ◇, 0]-- Y
	 * </pre>
	 * 
	 * @param currentGraph
	 * @param nextGraph
	 * @return true if a simplification has been applied.
	 */
	@Deprecated
	static boolean observationCaseRule(Graph currentGraph, Graph nextGraph) {
		if ((currentGraph == null) || (nextGraph == null)) {
			CSTNU.LOG.info("One parameter is null. Game over");
			return false;
		}

		final int n = currentGraph.getVertexCount();
		final Node[] node = currentGraph.getVerticesArray();
		Node X, Y, P;
		Edge XY, YX, YP;
		boolean reductionApplied = false;

		CSTNU.LOG.finer("Observation Case Rule: start.");
		for (int i = 0; i < n; i++) {
			X = node[i];
			for (int j = 0; j < n; j++) {
				if (i == j) continue; // self loop are useless!
				Y = node[j];
				XY = currentGraph.findEdge(X, Y);
				YX = currentGraph.findEdge(Y, X);
				if ((XY == null) || (YX == null)) continue;

				final Set<Entry<Label, Integer>> XYMap = XY.labeledValueSet();
				final Set<Entry<Label, Integer>> YXMap = YX.labeledValueSet();
				for (final Entry<Label, Integer> XYEntry : XYMap) {
					final Label l1 = XYEntry.getKey();
					final Integer u = XYEntry.getValue();
					for (final Entry<Label, Integer> YXEntry : YXMap) {
						final Label l2 = YXEntry.getKey();
						final Integer v = YXEntry.getValue();
						if (v >= 0 || u >= -v) continue;

						Literal p = l1.getUniqueDifferentLiteral(l2);
						if (p == null) continue;

						P = nextGraph.getObservable(p);
						// if (P == null) {
						// throw new NullPointerException("P cannot be null because the found literal is " + p);
						// }
						YP = nextGraph.findEdge(nextGraph.getNode(Y.getName()), nextGraph.getNode(P.getName()));
						CSTNU.LOG.finest("X node: " + X);
						CSTNU.LOG.finest("Y node: " + Y);
						CSTNU.LOG.finest("XY edge: " + XY);
						CSTNU.LOG.finest("YX edge: " + YX);
						CSTNU.LOG.finest("P node: " + P);
						CSTNU.LOG.finest("YP edge: " + YP);
						final Label l1WithoutP = new Label(l1);
						l1WithoutP.remove(p);
						l1WithoutP.remove(p.negation());
						final Label l2WithoutP = new Label(l2);
						l2WithoutP.remove(p);
						l2WithoutP.remove(p.negation());
						final Label[] alphaBetaGammaPart = CSTNU.getAlphaBetaGamma(l1WithoutP, l2WithoutP);
						final Label alpha = alphaBetaGammaPart[0];

						Label abg = alpha.conjunction(l2WithoutP);
						if (abg == null) continue;
						// if (!checkNodeLabelsSubsumption(Y, P, abg, (YP == null) ? "e" + Y.getName() + P.getName() : YP.getName(), "Observation Case Rule"))
						// continue;// THERE IS A MORE GENERAL CHECK

						if (YP == null) {
							YP = new Edge("e" + Y.getName() + P.getName(), Edge.Type.derived);
							nextGraph.addEdge(YP, nextGraph.getNode(Y.getName()), nextGraph.getNode(P.getName()));
							LOG.finer("observationCaseRule: added edge " + YP.getName());
						}
						final Integer oldZ = YP.getValue(abg);
						final String oldYP = YP.toString();
						if ((oldZ != null) && (oldZ <= 0)) continue;
						if (YP.mergeLabeledValue(abg, 0)) {
							reductionApplied = true;
							ObsCaseRule++;
							CSTNU.LOG.finer("Observation Case Rule applied to edge " + oldYP + ":\n"
									+ "partic: " + X.getName() + " <---(" + l2 + ", ◇, " + v + ")--- " + Y.getName()
									+ " <---(" + l1 + ", ◇, " + u + ")--- " + X.getName() + "\nresult: " + P.getName()
									+ " <---(" + abg + ", ◇, 0)--- " + Y.getName() + "; old value: " + oldZ);
							CSTNU.LOG.finer("Edge " + YP.getName() + " after the rule: " + YP.toString());
						}
					}
				}
			}
		}
		CSTNU.LOG.finer("Observation Case Rule: end.");
		return reductionApplied;
	}

	/**
	 * Executes one step of the dynamic controllability check.
	 * 
	 * @param i the number of cycle of the check. This parameter is used only to log some information.
	 * @param currentGraph the current graph. It will be never overwritten.
	 * @param nextGraph the next graph. It has be instantiate as a copy of current graph. It will contain the results of
	 *            reduction at the end of the execution.
	 * @param distanceGraph the AllMax Projection of nextGraph. It will be instantiate by the method.
	 * @param instantaneousReaction
	 * @return (reductionsApplied, Inconsistency). reductionApplied is true if at least one reduction has been applied
	 *         and the nextGraph is different from the current. Inconsistency is true if AllMax Projection of nextGraph
	 *         results to have negative loops.
	 * @throws WellDefinitionException if the nextGraph is not well defined (does not observe all well definition properties). If this exception occurs, then
	 *             there is a problem in the rules coding.
	 */
	static Entry<Boolean, Boolean> oneStepDynamicControllability(int i, Graph currentGraph, Graph nextGraph, Graph distanceGraph, boolean instantaneousReaction)
			throws WellDefinitionException {
		boolean reductionApplied = false;// FIXME uso reductionApplied or currentGraph.hasSameEdgesOf(nextGraph)?

		Graph originalGraph = new Graph();
		originalGraph.clone(currentGraph);
		distanceGraph.clone(CSTNU.makeAllMaxProjection(currentGraph));
		CSTNU.LOG.info("AllMax Projection check...");
		if (!CSTNU.minimalDistanceGraphFast(distanceGraph)) {
			CSTNU.LOG.info("The all max projection graph has negative loops at the start of cycle " + i + ": stop!");
			return new SimpleEntry<>(reductionApplied, true);
		}
		CSTNU.LOG.info("AllMax Projection check done.\n");
		CSTNU.LOG.info("Label modifications phase...");
		CSTNU.labelModificationR0R2R4(currentGraph, instantaneousReaction);
		reductionApplied = !originalGraph.hasSameEdgesOf(currentGraph);
		nextGraph.clone(currentGraph);
		// CSTNU.observationCaseRule(currentGraph, nextGraph);
		CSTNU.labelModificationR1R3R5(currentGraph, nextGraph, instantaneousReaction);
		CSTNU.negativeQStarR6(currentGraph, nextGraph);
		reductionApplied = !currentGraph.hasSameEdgesOf(nextGraph) || reductionApplied; // .hasAllEdgesOf is first
		CSTNU.LOG.info("Label modifications phase done.\n");
		// because i need the log!!!
		currentGraph.clone(nextGraph);
		CSTNU.LOG.info("Rules phase...");
		CSTNU.noCaseRule(currentGraph, nextGraph);
		CSTNU.upperCaseRule(currentGraph, nextGraph);
		CSTNU.crossCaseRule(currentGraph, nextGraph);
		CSTNU.lowerCaseRule(currentGraph, nextGraph);
		CSTNU.caseLabelRemovalRule(currentGraph, nextGraph);
		// reductionApplied = CSTNU.labelModificationR4(currentGraph, nextGraph) ? true : reductionApplied;
		reductionApplied = !currentGraph.hasSameEdgesOf(nextGraph) || reductionApplied; // .hasAllEdgesOf is first because i need the log!!!
		CSTNU.LOG.info("Rules phase done.\n");

		checkWellDefinitionProperties(nextGraph);

		if (!reductionApplied) {
			CSTNU.LOG.info("No more reductions applied at cycle " + i + ".\n");
		}
		return new SimpleEntry<>(reductionApplied, false);
	}

	/**
	 * Executes one step of the dynamic consistency check.
	 * 
	 * @param i the number of cycle of the check. This parameter is used only to log some information.
	 * @param currentGraph the current graph. It will be never overwritten.
	 * @param nextGraph the next graph. It has be instantiate as a copy of current graph. It will contain the results of
	 *            reduction at the end of the execution.
	 * @param distanceGraph the AllMax Projection of nextGraph. It will be instantiate by the method.
	 * @param instantaneousReaction true is it is admitted that observation points and other points depending from the observed proposition can be executed in
	 *            the same 'instant'.
	 * @return (reductionsApplied, Inconsistency). reductionApplied is true if at least one reduction has been applied
	 *         and the nextGraph is different from the current. Inconsistency is true if AllMax Projection of nextGraph
	 *         results to have negative loops.
	 * @throws WellDefinitionException if the nextGraph is not well defined (does not observe all well definition properties). If this exception occurs, then
	 *             there is a problem in the rules coding.
	 */
	static Entry<Boolean, Boolean> oneStepDynamicConsistency(int i, Graph currentGraph, Graph nextGraph, Graph distanceGraph, boolean instantaneousReaction)
			throws WellDefinitionException {
		boolean reductionApplied = false;// FIXME uso reductionApplied or currentGraph.hasSameEdgesOf(nextGraph)?

		Graph originalGraph = new Graph();
		originalGraph.clone(currentGraph);
		distanceGraph.clone(CSTNU.makeAllMaxProjection(currentGraph));
		CSTNU.LOG.info("AllMax Projection check...");
		if (!CSTNU.minimalDistanceGraphFast(distanceGraph)) {
			CSTNU.LOG.info("The all max projection graph has negative loops at the start of cycle " + i + ": stop!");
			return new SimpleEntry<>(reductionApplied, true);
		}
		CSTNU.LOG.info("AllMax Projection check done.\n");
		CSTNU.LOG.info("Label modifications phase...");
		CSTNU.labelModificationR0R2R4(currentGraph, instantaneousReaction);
		reductionApplied = !originalGraph.hasSameEdgesOf(currentGraph);
		nextGraph.clone(currentGraph);
		// CSTNU.observationCaseRule(currentGraph, nextGraph);
		CSTNU.labelModificationR1R3R5(currentGraph, nextGraph, instantaneousReaction);
		reductionApplied = !currentGraph.hasSameEdgesOf(nextGraph);
		reductionApplied = CSTNU.negativeQStarR6(currentGraph, nextGraph) || reductionApplied;
		reductionApplied = !currentGraph.hasSameEdgesOf(nextGraph);
		CSTNU.LOG.info("Label modifications phase done.\n");
		// because i need the log!!!
		currentGraph.clone(nextGraph);
		CSTNU.LOG.info("Rules phase...");
		CSTNU.noCaseRule(currentGraph, nextGraph);
		reductionApplied = !currentGraph.hasSameEdgesOf(nextGraph) || reductionApplied; // .hasAllEdgesOf is first because i need the log!!!
		CSTNU.LOG.info("Rules phase done.\n");

		checkWellDefinitionProperties(nextGraph);

		if (!reductionApplied) {
			CSTNU.LOG.info("No more reductions applied at cycle " + i + ".\n");
		}
		return new SimpleEntry<>(reductionApplied, false);
	}

	/**
	 * Checks the controllability of a labeled STNU instance and, if the instance is controllable, determines all the
	 * minimal ranges for the constraints.
	 * 
	 * @param g the original graph that has to be checked. If the check is successful, g is modified and it contains all
	 *            minimized constraints; otherwise, it is not modified.
	 * @return true the graph is dynamically controllable, false otherwise.
	 */
	static public boolean stnuRules(Graph g) {
		if (g == null) return false;

		Graph currentGraph, nextGraph, distanceGraph;
		currentGraph = new Graph(g);
		try {
			CSTNU.initUpperLowerLabelDataStructure(currentGraph);
		}
		catch (IllegalArgumentException e) {
			throw new IllegalArgumentException("The graph has a problem and it cannot be initialize: " + e.getMessage());
		}
		final int n = currentGraph.getVertexCount();
		int k = currentGraph.getUpperLabeledEdges().size();
		if (k == 0) k = 1;
		int p = currentGraph.getPropositions().size();
		if (p == 0) p = 1;
		int i;

		distanceGraph = CSTNU.makeAllMaxProjection(currentGraph);
		CSTNU.LOG.finer("Initial All Max Projection check.\n");
		if (!CSTNU.minimalDistanceGraphFast(distanceGraph)) {
			CSTNU.LOG.info("The initial distance graph has negative cycles: stop!");
			return false;
		}
		CSTNU.LOG.finer("done");

		boolean reductionApplied = false;
		nextGraph = new Graph(currentGraph);
		for (i = 1; i <= (n * k * p); i++) {
			reductionApplied = false;
			CSTNU.LOG.info("*** Cycle " + i + " ***");
			CSTNU.LOG.finer("Rules phase...");
			reductionApplied = CSTNU.noCaseRule(currentGraph, nextGraph) ? true : reductionApplied;
			reductionApplied = CSTNU.upperCaseRule(currentGraph, nextGraph) ? true : reductionApplied;
			reductionApplied = CSTNU.crossCaseRule(currentGraph, nextGraph) ? true : reductionApplied;
			reductionApplied = CSTNU.lowerCaseRule(currentGraph, nextGraph) ? true : reductionApplied;
			reductionApplied = CSTNU.caseLabelRemovalRule(currentGraph, nextGraph) ? true : reductionApplied;
			CSTNU.LOG.finer("done.");
			currentGraph = new Graph(nextGraph);

			if (!reductionApplied) {
				CSTNU.LOG.finer("No more reductions applied at cycle " + i);
				break;
			}
		}

		distanceGraph = CSTNU.makeAllMaxProjection(currentGraph);
		CSTNU.LOG.finer("All Max Projection check.\n");
		if (!CSTNU.minimalDistanceGraphFast(distanceGraph)) {
			CSTNU.LOG.info("The all max projection graph has negative cycles: stop!\n");
			return false;
		}
		CSTNU.LOG.info("Stable state reached. Number of minimization cycles: " + ((i > (n * k * p)) ? (i - 1) : i));
		// Put all data structures of currentGraph in g
		CSTNU.LOG.finer("Original graph: " + g);
		CSTNU.LOG.finer("Determined graph: " + currentGraph);
		g.takeIn(currentGraph);
		return true;
	}

	/**
	 * Apply Morris upper case reduction (see page 1196 of the article).
	 * 
	 * <pre>
	 *      l1, B:x     l2, y             l1l2, B:x+y
	 * A  <---------C <--------D adds A <-------------D
	 * </pre>
	 * 
	 * @param currentGraph the originating graph.
	 * @param nextGraph the graph where to write the new constraints.
	 * @return true if a reduction is applied at least
	 */
	static boolean upperCaseRule(Graph currentGraph, Graph nextGraph) {
		if ((currentGraph == null) || (nextGraph == null)) {
			CSTNU.LOG.info("One parameter is null. Game over");
			return false;
		}

		final Set<Edge> upperCaseEdge = currentGraph.getUpperLabeledEdges();

		/*
		 * I use the same node/edge ids of the Morris paper: A, C, D for nodes, and CA, DC, and DA for edges.
		 */
		Node A, C, D;
		Edge DA;
		boolean reductionApplied = false;
		Set<Entry<Entry<Label, String>, Integer>> CAMap;
		CSTNU.LOG.finer("Upper Case Rule: start.");
		for (final Edge CA : upperCaseEdge) {
			CAMap = CA.getUpperLabelSet();
			if (CAMap.size() == 0) continue;
			C = currentGraph.getSource(CA);
			A = currentGraph.getDest(CA);

			for (final Edge DC : currentGraph.getInEdges(C)) {
				D = currentGraph.getSource(DC);
				if (C.equalsByName(D) || A.equalsByName(D)) continue;// it is useless to consider self loop.

				DA = nextGraph.findEdge(nextGraph.getNode(D.getName()), nextGraph.getNode(A.getName()));
				final Set<Entry<Label, Integer>> DCMap = DC.labeledValueSet();

				for (final Entry<Entry<Label, String>, Integer> entryCA : CAMap) {
					final Label l1 = entryCA.getKey().getKey();
					final String upperCaseNode = entryCA.getKey().getValue();
					final Integer x = entryCA.getValue();

					for (final Entry<Label, Integer> entryDC : DCMap) {
						final Label l2 = entryDC.getKey();
						final Label l1l2 = l1.conjunction(l2);
						if (l1l2 == null) continue;
						// if (!checkNodeLabelsSubsumption(D, A, l1l2, (DA == null) ? "e" + D.getName() + A.getName() : DA.getName(), "Upper Case Rule"))
						// continue;// there is a more general check
						final Integer y = entryDC.getValue();
						if (DA == null) {
							DA = new Edge("e" + D.getName() + A.getName(), Edge.Type.derived);
							nextGraph.addEdge(DA, nextGraph.getNode(D.getName()), nextGraph.getNode(A.getName()));
							LOG.finer("upperCaseRule: added edge " + DA.getName());
						}
						final Integer oldZ = DA.getUpperLabelValue(l1l2, upperCaseNode);
						final Integer z = x + y;
						final String oldDA = DA.toString();
						// if ((oldZ != null) && (oldZ <= z)) continue;

						if (DA.mergeUpperLabelValue(l1l2, upperCaseNode, z)) {
							reductionApplied = true;
							CSTNU.LOG.finer("Upper Case applied to edge " + oldDA + ":\n" + "partic: "
									+ A.getName() + " <---(" + l1 + ", " + upperCaseNode.toUpperCase() + ", " + x + ")--- " + C.getName()
									+ " <---(" + l2 + ", -," + y + ")--- " + D.getName()
									+ "\nresult: " + A.getName() + " <---(" + l1l2 + ", " + upperCaseNode.toUpperCase() + ", " + z + ")--- " + D.getName()
									+ "; old value: " + oldZ);
							if (!z.equals(oldZ)) CSTNU.LOG.finer("Edge " + DA.getName() + " after the rule: " + DA.toString());
						}
					}
				}
			}
		}
		CSTNU.LOG.finer("Upper Case Rule: end.");
		return reductionApplied;
	}

	/**
	 * Returns the sum of all negative values (ignoring their labels) present in the edges of a graph.
	 * If an edge has more than one negative values, only the minimum among them is considered.
	 * For contingent link, also the lower case value is considered.
	 * 
	 * @param g
	 * @return the sum of all negative value (negative value)
	 */
	private static int getSumOfNegativeEdgeValues(Graph g) {
		int sum = 0;
		if (g == null || g.getEdgeCount() == 0) return sum;

		for (Edge e : g.getEdges()) {
			Integer min = e.getMinValue();
			// Integer minLC = e.getMinLowerLabeledValue();
			if (min != null && min < 0) {
				// if (minLC != null) {
				// if (min.compareTo(minLC) > 0 ) min = minLC;
				// }
				sum += min;
			}
		}
		LOG.finer("The sum of all negative values is " + sum);
		return sum;
	}

}
